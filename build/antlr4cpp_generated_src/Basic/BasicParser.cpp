
// Generated from Basic.g4 by ANTLR 4.13.2


#include "BasicVisitor.h"

#include "BasicParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct BasicParserStaticData final {
  BasicParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  BasicParserStaticData(const BasicParserStaticData&) = delete;
  BasicParserStaticData(BasicParserStaticData&&) = delete;
  BasicParserStaticData& operator=(const BasicParserStaticData&) = delete;
  BasicParserStaticData& operator=(BasicParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag basicParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<BasicParserStaticData> basicParserStaticData = nullptr;

void basicParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (basicParserStaticData != nullptr) {
    return;
  }
#else
  assert(basicParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<BasicParserStaticData>(
    std::vector<std::string>{
      "prog", "line", "amperoper", "linenumber", "amprstmt", "statement", 
      "vardecl", "printstmt1", "printlist", "getstmt", "letstmt", "variableassignment", 
      "relop", "neq", "ifstmt", "forstmt1", "forstmt2", "nextstmt", "inputstmt", 
      "readstmt", "dimstmt", "gotostmt", "gosubstmt", "pokestmt", "callstmt", 
      "hplotstmt", "vplotstmt", "plotstmt", "ongotostmt", "ongosubstmt", 
      "vtabstmnt", "htabstmnt", "himemstmt", "lomemstmt", "datastmt", "datum", 
      "waitstmt", "xdrawstmt", "drawstmt", "defstmt", "tabstmt", "speedstmt", 
      "rotstmt", "scalestmt", "colorstmt", "hcolorstmt", "hlinstmt", "vlinstmt", 
      "onerrstmt", "prstmt", "instmt", "storestmt", "recallstmt", "liststmt", 
      "popstmt", "amptstmt", "includestmt", "endstmt", "returnstmt", "restorestmt", 
      "number", "func_", "signExpression", "exponentExpression", "multiplyingExpression", 
      "addingExpression", "relationalExpression", "expression", "var_", 
      "varname", "varsuffix", "varlist", "exprlist", "sqrfunc", "chrfunc", 
      "lenfunc", "ascfunc", "midfunc", "pdlfunc", "peekfunc", "intfunc", 
      "spcfunc", "frefunc", "posfunc", "usrfunc", "leftfunc", "rightfunc", 
      "strfunc", "fnfunc", "valfunc", "scrnfunc", "sinfunc", "cosfunc", 
      "tanfunc", "atnfunc", "rndfunc", "sgnfunc", "expfunc", "logfunc", 
      "absfunc", "tabfunc"
    },
    std::vector<std::string>{
      "", "'$'", "'%'", "'RETURN'", "'\\u8868\\u793A'", "'GOTO'", "'GOSUB'", 
      "'IF'", "'NEXT'", "'THEN'", "'REM'", "'CHR$'", "'MID$'", "'LEFT$'", 
      "'RIGHT$'", "'STR$'", "'('", "')'", "'+'", "'-'", "'*'", "'/'", "'CLEAR'", 
      "'>: '", "'<: '", "'>'", "'<'", "','", "'LIST'", "'RUN'", "'END'", 
      "'\\u30EC\\u30C3\\u30C8'", "'='", "'FOR'", "'TO'", "'STEP'", "'INPUT'", 
      "';'", "'DIM'", "'SQR'", "':'", "'TEXT'", "'HGR'", "'HGR2'", "'LEN'", 
      "'CALL'", "'ASC'", "'HPLOT'", "'VPLOT'", "'PR#'", "'IN#'", "'VTAB'", 
      "'HTAB'", "'HOME'", "'ON'", "'PDL'", "'PLOT'", "'PEEK'", "'POKE'", 
      "'INT'", "'STOP'", "'HIMEM'", "'LOMEM'", "'FLASH'", "'INVERSE'", "'NORMAL'", 
      "'ONERR'", "'SPC'", "'FRE'", "'POS'", "'USR'", "'TRACE'", "'NOTRACE'", 
      "'AND'", "'OR'", "'DATA'", "'WAIT'", "'READ'", "'XDRAW'", "'DRAW'", 
      "'AT'", "'DEF'", "'FN'", "'VAL'", "'TAB'", "'SPEED'", "'ROT'", "'SCALE'", 
      "'COLOR'", "'HCOLOR'", "'HLIN'", "'VLIN'", "'SCRN'", "'POP'", "'SHLOAD'", 
      "'SIN'", "'COS'", "'TAN'", "'ATN'", "'RND'", "'SGN'", "'EXP'", "'LOG'", 
      "'ABS'", "'STORE'", "'RECALL'", "'GET'", "'^'", "'&'", "'GR'", "'NOT'", 
      "'RESTORE'", "'SAVE'", "'LOAD'", "'\\u003F'", "'INCLUDE'", "'CLS'"
    },
    std::vector<std::string>{
      "", "DOLLAR", "PERCENT", "RETURN", "PRINT", "GOTO", "GOSUB", "IF", 
      "NEXT", "THEN", "REM", "CHR", "MID", "LEFT", "RIGHT", "STR", "LPAREN", 
      "RPAREN", "PLUS", "MINUS", "TIMES", "DIV", "CLEAR", "GTE", "LTE", 
      "GT", "LT", "COMMA", "LIST", "RUN", "END", "LET", "EQ", "FOR", "TO", 
      "STEP", "INPUT", "SEMICOLON", "DIM", "SQR", "COLON", "TEXT", "HGR", 
      "HGR2", "LEN", "CALL", "ASC", "HPLOT", "VPLOT", "PRNUMBER", "INNUMBER", 
      "VTAB", "HTAB", "HOME", "ON", "PDL", "PLOT", "PEEK", "POKE", "INTF", 
      "STOP", "HIMEM", "LOMEM", "FLASH", "INVERSE", "NORMAL", "ONERR", "SPC", 
      "FRE", "POS", "USR", "TRACE", "NOTRACE", "AND", "OR", "DATA", "WAIT", 
      "READ", "XDRAW", "DRAW", "AT", "DEF", "FN", "VAL", "TAB", "SPEED", 
      "ROT", "SCALE", "COLOR", "HCOLOR", "HLIN", "VLIN", "SCRN", "POP", 
      "SHLOAD", "SIN", "COS", "TAN", "ATN", "RND", "SGN", "EXP", "LOG", 
      "ABS", "STORE", "RECALL", "GET", "EXPONENT", "AMPERSAND", "GR", "NOT", 
      "RESTORE", "SAVE", "LOAD", "QUESTION", "INCLUDE", "CLS", "COMMENT", 
      "STRINGLITERAL", "LETTERS", "NUMBER", "FLOAT", "WS"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,122,909,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
  	56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,
  	63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,
  	70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,
  	77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,
  	84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
  	91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,7,
  	98,2,99,7,99,2,100,7,100,1,0,4,0,204,8,0,11,0,12,0,205,1,0,1,0,1,1,1,
  	1,1,1,1,1,3,1,214,8,1,5,1,216,8,1,10,1,12,1,219,9,1,1,1,1,1,3,1,223,8,
  	1,1,2,1,2,1,3,1,3,1,4,3,4,230,8,4,1,4,1,4,1,4,3,4,235,8,4,1,5,1,5,1,5,
  	1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,
  	5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,
  	1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,
  	5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,302,8,5,1,6,1,6,1,6,1,6,1,6,
  	5,6,309,8,6,10,6,12,6,312,9,6,1,7,1,7,3,7,316,8,7,1,8,1,8,1,8,3,8,321,
  	8,8,5,8,323,8,8,10,8,12,8,326,9,8,1,9,1,9,1,9,1,10,3,10,332,8,10,1,10,
  	1,10,1,11,1,11,1,11,1,11,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,
  	1,12,1,12,1,12,1,12,1,12,3,12,354,8,12,1,13,1,13,1,13,1,14,1,14,1,14,
  	3,14,362,8,14,1,14,1,14,3,14,366,8,14,1,15,1,15,1,15,1,15,1,15,1,15,1,
  	15,1,15,3,15,376,8,15,1,15,1,15,1,15,3,15,381,8,15,3,15,383,8,15,1,16,
  	1,16,1,16,1,16,1,16,1,16,1,16,1,16,3,16,393,8,16,1,17,1,17,1,17,1,17,
  	5,17,399,8,17,10,17,12,17,402,9,17,3,17,404,8,17,1,18,1,18,1,18,3,18,
  	409,8,18,1,18,1,18,1,19,1,19,1,19,1,20,1,20,1,20,1,21,1,21,1,21,1,22,
  	1,22,1,22,1,23,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,25,1,25,1,25,1,25,
  	1,25,3,25,438,8,25,1,25,1,25,1,25,1,25,1,25,5,25,445,8,25,10,25,12,25,
  	448,9,25,1,26,1,26,1,26,1,26,1,26,3,26,455,8,26,1,26,1,26,1,26,1,26,1,
  	26,5,26,462,8,26,10,26,12,26,465,9,26,1,27,1,27,1,27,1,27,1,27,1,28,1,
  	28,1,28,1,28,1,28,1,28,5,28,478,8,28,10,28,12,28,481,9,28,1,29,1,29,1,
  	29,1,29,1,29,1,29,5,29,489,8,29,10,29,12,29,492,9,29,1,30,1,30,1,30,1,
  	31,1,31,1,31,1,32,1,32,1,32,1,32,1,33,1,33,1,33,1,33,1,34,1,34,1,34,1,
  	34,3,34,512,8,34,5,34,514,8,34,10,34,12,34,517,9,34,1,35,1,35,3,35,521,
  	8,35,1,36,1,36,1,36,1,36,1,36,1,36,3,36,529,8,36,1,37,1,37,1,37,1,37,
  	1,37,1,37,1,37,3,37,538,8,37,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,
  	547,8,38,1,39,1,39,3,39,551,8,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,
  	40,1,40,1,40,1,40,1,40,1,41,1,41,1,41,1,41,1,42,1,42,1,42,1,42,1,43,1,
  	43,1,43,1,43,1,44,1,44,1,44,1,44,1,45,1,45,1,45,1,45,1,46,1,46,1,46,1,
  	46,1,46,1,46,1,46,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,48,1,48,1,48,1,
  	48,1,49,1,49,1,49,1,50,1,50,1,50,1,51,1,51,1,51,1,52,1,52,1,52,1,53,1,
  	53,3,53,617,8,53,1,54,1,54,1,54,1,54,1,54,3,54,624,8,54,1,55,1,55,1,55,
  	1,56,1,56,1,56,1,57,1,57,1,58,1,58,1,59,1,59,1,60,3,60,639,8,60,1,60,
  	1,60,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,
  	1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,
  	1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,3,61,678,8,61,1,62,3,62,681,8,
  	62,1,62,3,62,684,8,62,1,62,1,62,1,63,1,63,1,63,5,63,691,8,63,10,63,12,
  	63,694,9,63,1,64,1,64,1,64,5,64,699,8,64,10,64,12,64,702,9,64,1,65,1,
  	65,1,65,5,65,707,8,65,10,65,12,65,710,9,65,1,66,1,66,1,66,1,66,3,66,716,
  	8,66,1,67,1,67,1,67,1,67,5,67,722,8,67,10,67,12,67,725,9,67,3,67,727,
  	8,67,1,68,1,68,3,68,731,8,68,1,69,1,69,5,69,735,8,69,10,69,12,69,738,
  	9,69,1,70,1,70,1,71,1,71,1,71,5,71,745,8,71,10,71,12,71,748,9,71,1,72,
  	1,72,1,72,5,72,753,8,72,10,72,12,72,756,9,72,1,73,1,73,1,73,1,73,1,73,
  	1,74,1,74,1,74,1,74,1,74,1,75,1,75,1,75,1,75,1,75,1,76,1,76,1,76,1,76,
  	1,76,1,77,1,77,1,77,1,77,1,77,1,77,1,77,1,77,1,77,1,78,1,78,1,78,1,78,
  	1,78,1,79,1,79,1,79,1,79,1,79,1,80,1,80,1,80,1,80,1,80,1,81,1,81,1,81,
  	1,81,1,81,1,82,1,82,1,82,1,82,1,82,1,83,1,83,1,83,1,83,1,83,1,84,1,84,
  	1,84,1,84,1,84,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,86,1,86,1,86,1,86,
  	1,86,1,86,1,86,1,87,1,87,1,87,1,87,1,87,1,88,1,88,1,88,1,88,1,88,1,88,
  	1,89,1,89,1,89,1,89,1,89,1,90,1,90,1,90,1,90,1,90,1,90,1,90,1,91,1,91,
  	1,91,1,91,1,91,1,92,1,92,1,92,1,92,1,92,1,93,1,93,1,93,1,93,1,93,1,94,
  	1,94,1,94,1,94,1,94,1,95,1,95,1,95,1,95,1,95,1,96,1,96,1,96,1,96,1,96,
  	1,97,1,97,1,97,1,97,1,97,1,98,1,98,1,98,1,98,1,98,1,99,1,99,1,99,1,99,
  	1,99,1,100,1,100,1,100,1,100,1,100,1,100,0,0,101,0,2,4,6,8,10,12,14,16,
  	18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,
  	64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,
  	108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,
  	144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,
  	180,182,184,186,188,190,192,194,196,198,200,0,8,2,0,4,4,114,114,2,0,27,
  	27,37,37,1,0,18,19,1,0,120,121,1,0,20,21,1,0,73,74,1,0,119,120,1,0,1,
  	2,961,0,203,1,0,0,0,2,209,1,0,0,0,4,224,1,0,0,0,6,226,1,0,0,0,8,234,1,
  	0,0,0,10,301,1,0,0,0,12,303,1,0,0,0,14,313,1,0,0,0,16,317,1,0,0,0,18,
  	327,1,0,0,0,20,331,1,0,0,0,22,335,1,0,0,0,24,353,1,0,0,0,26,355,1,0,0,
  	0,28,358,1,0,0,0,30,367,1,0,0,0,32,384,1,0,0,0,34,394,1,0,0,0,36,405,
  	1,0,0,0,38,412,1,0,0,0,40,415,1,0,0,0,42,418,1,0,0,0,44,421,1,0,0,0,46,
  	424,1,0,0,0,48,429,1,0,0,0,50,432,1,0,0,0,52,449,1,0,0,0,54,466,1,0,0,
  	0,56,471,1,0,0,0,58,482,1,0,0,0,60,493,1,0,0,0,62,496,1,0,0,0,64,499,
  	1,0,0,0,66,503,1,0,0,0,68,507,1,0,0,0,70,520,1,0,0,0,72,522,1,0,0,0,74,
  	530,1,0,0,0,76,539,1,0,0,0,78,548,1,0,0,0,80,559,1,0,0,0,82,564,1,0,0,
  	0,84,568,1,0,0,0,86,572,1,0,0,0,88,576,1,0,0,0,90,580,1,0,0,0,92,584,
  	1,0,0,0,94,591,1,0,0,0,96,598,1,0,0,0,98,602,1,0,0,0,100,605,1,0,0,0,
  	102,608,1,0,0,0,104,611,1,0,0,0,106,614,1,0,0,0,108,618,1,0,0,0,110,625,
  	1,0,0,0,112,628,1,0,0,0,114,631,1,0,0,0,116,633,1,0,0,0,118,635,1,0,0,
  	0,120,638,1,0,0,0,122,677,1,0,0,0,124,680,1,0,0,0,126,687,1,0,0,0,128,
  	695,1,0,0,0,130,703,1,0,0,0,132,711,1,0,0,0,134,726,1,0,0,0,136,728,1,
  	0,0,0,138,732,1,0,0,0,140,739,1,0,0,0,142,741,1,0,0,0,144,749,1,0,0,0,
  	146,757,1,0,0,0,148,762,1,0,0,0,150,767,1,0,0,0,152,772,1,0,0,0,154,777,
  	1,0,0,0,156,786,1,0,0,0,158,791,1,0,0,0,160,796,1,0,0,0,162,801,1,0,0,
  	0,164,806,1,0,0,0,166,811,1,0,0,0,168,816,1,0,0,0,170,821,1,0,0,0,172,
  	828,1,0,0,0,174,835,1,0,0,0,176,840,1,0,0,0,178,846,1,0,0,0,180,851,1,
  	0,0,0,182,858,1,0,0,0,184,863,1,0,0,0,186,868,1,0,0,0,188,873,1,0,0,0,
  	190,878,1,0,0,0,192,883,1,0,0,0,194,888,1,0,0,0,196,893,1,0,0,0,198,898,
  	1,0,0,0,200,903,1,0,0,0,202,204,3,2,1,0,203,202,1,0,0,0,204,205,1,0,0,
  	0,205,203,1,0,0,0,205,206,1,0,0,0,206,207,1,0,0,0,207,208,5,0,0,1,208,
  	1,1,0,0,0,209,222,3,6,3,0,210,217,3,8,4,0,211,213,5,40,0,0,212,214,3,
  	8,4,0,213,212,1,0,0,0,213,214,1,0,0,0,214,216,1,0,0,0,215,211,1,0,0,0,
  	216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,223,1,0,0,0,219,217,
  	1,0,0,0,220,223,5,117,0,0,221,223,5,10,0,0,222,210,1,0,0,0,222,220,1,
  	0,0,0,222,221,1,0,0,0,223,3,1,0,0,0,224,225,5,108,0,0,225,5,1,0,0,0,226,
  	227,5,120,0,0,227,7,1,0,0,0,228,230,3,4,2,0,229,228,1,0,0,0,229,230,1,
  	0,0,0,230,231,1,0,0,0,231,235,3,10,5,0,232,235,5,117,0,0,233,235,5,10,
  	0,0,234,229,1,0,0,0,234,232,1,0,0,0,234,233,1,0,0,0,235,9,1,0,0,0,236,
  	302,5,116,0,0,237,302,5,113,0,0,238,302,5,112,0,0,239,302,5,71,0,0,240,
  	302,5,72,0,0,241,302,5,63,0,0,242,302,5,64,0,0,243,302,5,109,0,0,244,
  	302,5,65,0,0,245,302,5,94,0,0,246,302,5,22,0,0,247,302,5,29,0,0,248,302,
  	5,60,0,0,249,302,5,41,0,0,250,302,5,53,0,0,251,302,5,42,0,0,252,302,5,
  	43,0,0,253,302,3,114,57,0,254,302,3,116,58,0,255,302,3,118,59,0,256,302,
  	3,110,55,0,257,302,3,108,54,0,258,302,3,106,53,0,259,302,3,102,51,0,260,
  	302,3,18,9,0,261,302,3,104,52,0,262,302,3,34,17,0,263,302,3,100,50,0,
  	264,302,3,98,49,0,265,302,3,96,48,0,266,302,3,92,46,0,267,302,3,94,47,
  	0,268,302,3,88,44,0,269,302,3,82,41,0,270,302,3,86,43,0,271,302,3,84,
  	42,0,272,302,3,90,45,0,273,302,3,64,32,0,274,302,3,66,33,0,275,302,3,
  	14,7,0,276,302,3,46,23,0,277,302,3,54,27,0,278,302,3,56,28,0,279,302,
  	3,58,29,0,280,302,3,28,14,0,281,302,3,30,15,0,282,302,3,32,16,0,283,302,
  	3,36,18,0,284,302,3,80,40,0,285,302,3,40,20,0,286,302,3,42,21,0,287,302,
  	3,44,22,0,288,302,3,48,24,0,289,302,3,38,19,0,290,302,3,50,25,0,291,302,
  	3,52,26,0,292,302,3,60,30,0,293,302,3,62,31,0,294,302,3,72,36,0,295,302,
  	3,68,34,0,296,302,3,74,37,0,297,302,3,76,38,0,298,302,3,78,39,0,299,302,
  	3,20,10,0,300,302,3,112,56,0,301,236,1,0,0,0,301,237,1,0,0,0,301,238,
  	1,0,0,0,301,239,1,0,0,0,301,240,1,0,0,0,301,241,1,0,0,0,301,242,1,0,0,
  	0,301,243,1,0,0,0,301,244,1,0,0,0,301,245,1,0,0,0,301,246,1,0,0,0,301,
  	247,1,0,0,0,301,248,1,0,0,0,301,249,1,0,0,0,301,250,1,0,0,0,301,251,1,
  	0,0,0,301,252,1,0,0,0,301,253,1,0,0,0,301,254,1,0,0,0,301,255,1,0,0,0,
  	301,256,1,0,0,0,301,257,1,0,0,0,301,258,1,0,0,0,301,259,1,0,0,0,301,260,
  	1,0,0,0,301,261,1,0,0,0,301,262,1,0,0,0,301,263,1,0,0,0,301,264,1,0,0,
  	0,301,265,1,0,0,0,301,266,1,0,0,0,301,267,1,0,0,0,301,268,1,0,0,0,301,
  	269,1,0,0,0,301,270,1,0,0,0,301,271,1,0,0,0,301,272,1,0,0,0,301,273,1,
  	0,0,0,301,274,1,0,0,0,301,275,1,0,0,0,301,276,1,0,0,0,301,277,1,0,0,0,
  	301,278,1,0,0,0,301,279,1,0,0,0,301,280,1,0,0,0,301,281,1,0,0,0,301,282,
  	1,0,0,0,301,283,1,0,0,0,301,284,1,0,0,0,301,285,1,0,0,0,301,286,1,0,0,
  	0,301,287,1,0,0,0,301,288,1,0,0,0,301,289,1,0,0,0,301,290,1,0,0,0,301,
  	291,1,0,0,0,301,292,1,0,0,0,301,293,1,0,0,0,301,294,1,0,0,0,301,295,1,
  	0,0,0,301,296,1,0,0,0,301,297,1,0,0,0,301,298,1,0,0,0,301,299,1,0,0,0,
  	301,300,1,0,0,0,302,11,1,0,0,0,303,310,3,136,68,0,304,305,5,16,0,0,305,
  	306,3,144,72,0,306,307,5,17,0,0,307,309,1,0,0,0,308,304,1,0,0,0,309,312,
  	1,0,0,0,310,308,1,0,0,0,310,311,1,0,0,0,311,13,1,0,0,0,312,310,1,0,0,
  	0,313,315,7,0,0,0,314,316,3,16,8,0,315,314,1,0,0,0,315,316,1,0,0,0,316,
  	15,1,0,0,0,317,324,3,134,67,0,318,320,7,1,0,0,319,321,3,134,67,0,320,
  	319,1,0,0,0,320,321,1,0,0,0,321,323,1,0,0,0,322,318,1,0,0,0,323,326,1,
  	0,0,0,324,322,1,0,0,0,324,325,1,0,0,0,325,17,1,0,0,0,326,324,1,0,0,0,
  	327,328,5,106,0,0,328,329,3,144,72,0,329,19,1,0,0,0,330,332,5,31,0,0,
  	331,330,1,0,0,0,331,332,1,0,0,0,332,333,1,0,0,0,333,334,3,22,11,0,334,
  	21,1,0,0,0,335,336,3,12,6,0,336,337,5,32,0,0,337,338,3,144,72,0,338,23,
  	1,0,0,0,339,354,5,23,0,0,340,341,5,25,0,0,341,354,5,32,0,0,342,343,5,
  	32,0,0,343,354,5,25,0,0,344,354,5,24,0,0,345,346,5,26,0,0,346,354,5,32,
  	0,0,347,348,5,32,0,0,348,354,5,26,0,0,349,354,3,26,13,0,350,354,5,32,
  	0,0,351,354,5,25,0,0,352,354,5,26,0,0,353,339,1,0,0,0,353,340,1,0,0,0,
  	353,342,1,0,0,0,353,344,1,0,0,0,353,345,1,0,0,0,353,347,1,0,0,0,353,349,
  	1,0,0,0,353,350,1,0,0,0,353,351,1,0,0,0,353,352,1,0,0,0,354,25,1,0,0,
  	0,355,356,5,26,0,0,356,357,5,25,0,0,357,27,1,0,0,0,358,359,5,7,0,0,359,
  	361,3,134,67,0,360,362,5,9,0,0,361,360,1,0,0,0,361,362,1,0,0,0,362,365,
  	1,0,0,0,363,366,3,10,5,0,364,366,3,6,3,0,365,363,1,0,0,0,365,364,1,0,
  	0,0,366,29,1,0,0,0,367,368,5,33,0,0,368,369,3,12,6,0,369,370,5,32,0,0,
  	370,371,3,134,67,0,371,372,5,34,0,0,372,375,3,134,67,0,373,374,5,35,0,
  	0,374,376,3,134,67,0,375,373,1,0,0,0,375,376,1,0,0,0,376,382,1,0,0,0,
  	377,378,3,10,5,0,378,380,5,8,0,0,379,381,3,12,6,0,380,379,1,0,0,0,380,
  	381,1,0,0,0,381,383,1,0,0,0,382,377,1,0,0,0,382,383,1,0,0,0,383,31,1,
  	0,0,0,384,385,5,33,0,0,385,386,3,12,6,0,386,387,5,32,0,0,387,388,3,134,
  	67,0,388,389,5,34,0,0,389,392,3,134,67,0,390,391,5,35,0,0,391,393,3,134,
  	67,0,392,390,1,0,0,0,392,393,1,0,0,0,393,33,1,0,0,0,394,403,5,8,0,0,395,
  	400,3,12,6,0,396,397,5,27,0,0,397,399,3,12,6,0,398,396,1,0,0,0,399,402,
  	1,0,0,0,400,398,1,0,0,0,400,401,1,0,0,0,401,404,1,0,0,0,402,400,1,0,0,
  	0,403,395,1,0,0,0,403,404,1,0,0,0,404,35,1,0,0,0,405,408,5,36,0,0,406,
  	407,5,118,0,0,407,409,7,1,0,0,408,406,1,0,0,0,408,409,1,0,0,0,409,410,
  	1,0,0,0,410,411,3,142,71,0,411,37,1,0,0,0,412,413,5,77,0,0,413,414,3,
  	142,71,0,414,39,1,0,0,0,415,416,5,38,0,0,416,417,3,142,71,0,417,41,1,
  	0,0,0,418,419,5,5,0,0,419,420,3,6,3,0,420,43,1,0,0,0,421,422,5,6,0,0,
  	422,423,3,134,67,0,423,45,1,0,0,0,424,425,5,58,0,0,425,426,3,134,67,0,
  	426,427,5,27,0,0,427,428,3,134,67,0,428,47,1,0,0,0,429,430,5,45,0,0,430,
  	431,3,144,72,0,431,49,1,0,0,0,432,437,5,47,0,0,433,434,3,134,67,0,434,
  	435,5,27,0,0,435,436,3,134,67,0,436,438,1,0,0,0,437,433,1,0,0,0,437,438,
  	1,0,0,0,438,446,1,0,0,0,439,440,5,34,0,0,440,441,3,134,67,0,441,442,5,
  	27,0,0,442,443,3,134,67,0,443,445,1,0,0,0,444,439,1,0,0,0,445,448,1,0,
  	0,0,446,444,1,0,0,0,446,447,1,0,0,0,447,51,1,0,0,0,448,446,1,0,0,0,449,
  	454,5,48,0,0,450,451,3,134,67,0,451,452,5,27,0,0,452,453,3,134,67,0,453,
  	455,1,0,0,0,454,450,1,0,0,0,454,455,1,0,0,0,455,463,1,0,0,0,456,457,5,
  	34,0,0,457,458,3,134,67,0,458,459,5,27,0,0,459,460,3,134,67,0,460,462,
  	1,0,0,0,461,456,1,0,0,0,462,465,1,0,0,0,463,461,1,0,0,0,463,464,1,0,0,
  	0,464,53,1,0,0,0,465,463,1,0,0,0,466,467,5,56,0,0,467,468,3,134,67,0,
  	468,469,5,27,0,0,469,470,3,134,67,0,470,55,1,0,0,0,471,472,5,54,0,0,472,
  	473,3,134,67,0,473,474,5,5,0,0,474,479,3,6,3,0,475,476,5,27,0,0,476,478,
  	3,6,3,0,477,475,1,0,0,0,478,481,1,0,0,0,479,477,1,0,0,0,479,480,1,0,0,
  	0,480,57,1,0,0,0,481,479,1,0,0,0,482,483,5,54,0,0,483,484,3,134,67,0,
  	484,485,5,6,0,0,485,490,3,6,3,0,486,487,5,27,0,0,487,489,3,6,3,0,488,
  	486,1,0,0,0,489,492,1,0,0,0,490,488,1,0,0,0,490,491,1,0,0,0,491,59,1,
  	0,0,0,492,490,1,0,0,0,493,494,5,51,0,0,494,495,3,134,67,0,495,61,1,0,
  	0,0,496,497,5,52,0,0,497,498,3,134,67,0,498,63,1,0,0,0,499,500,5,61,0,
  	0,500,501,5,40,0,0,501,502,3,134,67,0,502,65,1,0,0,0,503,504,5,62,0,0,
  	504,505,5,40,0,0,505,506,3,134,67,0,506,67,1,0,0,0,507,508,5,75,0,0,508,
  	515,3,70,35,0,509,511,5,27,0,0,510,512,3,70,35,0,511,510,1,0,0,0,511,
  	512,1,0,0,0,512,514,1,0,0,0,513,509,1,0,0,0,514,517,1,0,0,0,515,513,1,
  	0,0,0,515,516,1,0,0,0,516,69,1,0,0,0,517,515,1,0,0,0,518,521,3,120,60,
  	0,519,521,5,118,0,0,520,518,1,0,0,0,520,519,1,0,0,0,521,71,1,0,0,0,522,
  	523,5,76,0,0,523,524,3,134,67,0,524,525,5,27,0,0,525,528,3,134,67,0,526,
  	527,5,27,0,0,527,529,3,134,67,0,528,526,1,0,0,0,528,529,1,0,0,0,529,73,
  	1,0,0,0,530,531,5,78,0,0,531,537,3,134,67,0,532,533,5,80,0,0,533,534,
  	3,134,67,0,534,535,5,27,0,0,535,536,3,134,67,0,536,538,1,0,0,0,537,532,
  	1,0,0,0,537,538,1,0,0,0,538,75,1,0,0,0,539,540,5,79,0,0,540,546,3,134,
  	67,0,541,542,5,80,0,0,542,543,3,134,67,0,543,544,5,27,0,0,544,545,3,134,
  	67,0,545,547,1,0,0,0,546,541,1,0,0,0,546,547,1,0,0,0,547,77,1,0,0,0,548,
  	550,5,81,0,0,549,551,5,82,0,0,550,549,1,0,0,0,550,551,1,0,0,0,551,552,
  	1,0,0,0,552,553,3,136,68,0,553,554,5,16,0,0,554,555,3,136,68,0,555,556,
  	5,17,0,0,556,557,5,32,0,0,557,558,3,134,67,0,558,79,1,0,0,0,559,560,5,
  	84,0,0,560,561,5,16,0,0,561,562,3,134,67,0,562,563,5,17,0,0,563,81,1,
  	0,0,0,564,565,5,85,0,0,565,566,5,32,0,0,566,567,3,134,67,0,567,83,1,0,
  	0,0,568,569,5,86,0,0,569,570,5,32,0,0,570,571,3,134,67,0,571,85,1,0,0,
  	0,572,573,5,87,0,0,573,574,5,32,0,0,574,575,3,134,67,0,575,87,1,0,0,0,
  	576,577,5,88,0,0,577,578,5,32,0,0,578,579,3,134,67,0,579,89,1,0,0,0,580,
  	581,5,89,0,0,581,582,5,32,0,0,582,583,3,134,67,0,583,91,1,0,0,0,584,585,
  	5,90,0,0,585,586,3,134,67,0,586,587,5,27,0,0,587,588,3,134,67,0,588,589,
  	5,80,0,0,589,590,3,134,67,0,590,93,1,0,0,0,591,592,5,91,0,0,592,593,3,
  	134,67,0,593,594,5,27,0,0,594,595,3,134,67,0,595,596,5,80,0,0,596,597,
  	3,134,67,0,597,95,1,0,0,0,598,599,5,66,0,0,599,600,5,5,0,0,600,601,3,
  	6,3,0,601,97,1,0,0,0,602,603,5,49,0,0,603,604,5,120,0,0,604,99,1,0,0,
  	0,605,606,5,50,0,0,606,607,5,120,0,0,607,101,1,0,0,0,608,609,5,104,0,
  	0,609,610,3,12,6,0,610,103,1,0,0,0,611,612,5,105,0,0,612,613,3,12,6,0,
  	613,105,1,0,0,0,614,616,5,28,0,0,615,617,3,134,67,0,616,615,1,0,0,0,616,
  	617,1,0,0,0,617,107,1,0,0,0,618,623,5,93,0,0,619,620,3,134,67,0,620,621,
  	5,27,0,0,621,622,3,134,67,0,622,624,1,0,0,0,623,619,1,0,0,0,623,624,1,
  	0,0,0,624,109,1,0,0,0,625,626,5,108,0,0,626,627,3,134,67,0,627,111,1,
  	0,0,0,628,629,5,115,0,0,629,630,3,134,67,0,630,113,1,0,0,0,631,632,5,
  	30,0,0,632,115,1,0,0,0,633,634,5,3,0,0,634,117,1,0,0,0,635,636,5,111,
  	0,0,636,119,1,0,0,0,637,639,7,2,0,0,638,637,1,0,0,0,638,639,1,0,0,0,639,
  	640,1,0,0,0,640,641,7,3,0,0,641,121,1,0,0,0,642,678,5,118,0,0,643,678,
  	3,120,60,0,644,678,3,200,100,0,645,678,3,12,6,0,646,678,3,148,74,0,647,
  	678,3,146,73,0,648,678,3,150,75,0,649,678,3,174,87,0,650,678,3,152,76,
  	0,651,678,3,180,90,0,652,678,3,154,77,0,653,678,3,156,78,0,654,678,3,
  	158,79,0,655,678,3,160,80,0,656,678,3,162,81,0,657,678,3,164,82,0,658,
  	678,3,166,83,0,659,678,3,168,84,0,660,678,3,170,85,0,661,678,3,178,89,
  	0,662,678,3,172,86,0,663,678,3,176,88,0,664,678,3,182,91,0,665,678,3,
  	184,92,0,666,678,3,186,93,0,667,678,3,188,94,0,668,678,3,190,95,0,669,
  	678,3,192,96,0,670,678,3,194,97,0,671,678,3,196,98,0,672,678,3,198,99,
  	0,673,674,5,16,0,0,674,675,3,134,67,0,675,676,5,17,0,0,676,678,1,0,0,
  	0,677,642,1,0,0,0,677,643,1,0,0,0,677,644,1,0,0,0,677,645,1,0,0,0,677,
  	646,1,0,0,0,677,647,1,0,0,0,677,648,1,0,0,0,677,649,1,0,0,0,677,650,1,
  	0,0,0,677,651,1,0,0,0,677,652,1,0,0,0,677,653,1,0,0,0,677,654,1,0,0,0,
  	677,655,1,0,0,0,677,656,1,0,0,0,677,657,1,0,0,0,677,658,1,0,0,0,677,659,
  	1,0,0,0,677,660,1,0,0,0,677,661,1,0,0,0,677,662,1,0,0,0,677,663,1,0,0,
  	0,677,664,1,0,0,0,677,665,1,0,0,0,677,666,1,0,0,0,677,667,1,0,0,0,677,
  	668,1,0,0,0,677,669,1,0,0,0,677,670,1,0,0,0,677,671,1,0,0,0,677,672,1,
  	0,0,0,677,673,1,0,0,0,678,123,1,0,0,0,679,681,5,110,0,0,680,679,1,0,0,
  	0,680,681,1,0,0,0,681,683,1,0,0,0,682,684,7,2,0,0,683,682,1,0,0,0,683,
  	684,1,0,0,0,684,685,1,0,0,0,685,686,3,122,61,0,686,125,1,0,0,0,687,692,
  	3,124,62,0,688,689,5,107,0,0,689,691,3,124,62,0,690,688,1,0,0,0,691,694,
  	1,0,0,0,692,690,1,0,0,0,692,693,1,0,0,0,693,127,1,0,0,0,694,692,1,0,0,
  	0,695,700,3,126,63,0,696,697,7,4,0,0,697,699,3,126,63,0,698,696,1,0,0,
  	0,699,702,1,0,0,0,700,698,1,0,0,0,700,701,1,0,0,0,701,129,1,0,0,0,702,
  	700,1,0,0,0,703,708,3,128,64,0,704,705,7,2,0,0,705,707,3,128,64,0,706,
  	704,1,0,0,0,707,710,1,0,0,0,708,706,1,0,0,0,708,709,1,0,0,0,709,131,1,
  	0,0,0,710,708,1,0,0,0,711,715,3,130,65,0,712,713,3,24,12,0,713,714,3,
  	130,65,0,714,716,1,0,0,0,715,712,1,0,0,0,715,716,1,0,0,0,716,133,1,0,
  	0,0,717,727,3,122,61,0,718,723,3,132,66,0,719,720,7,5,0,0,720,722,3,132,
  	66,0,721,719,1,0,0,0,722,725,1,0,0,0,723,721,1,0,0,0,723,724,1,0,0,0,
  	724,727,1,0,0,0,725,723,1,0,0,0,726,717,1,0,0,0,726,718,1,0,0,0,727,135,
  	1,0,0,0,728,730,3,138,69,0,729,731,3,140,70,0,730,729,1,0,0,0,730,731,
  	1,0,0,0,731,137,1,0,0,0,732,736,5,119,0,0,733,735,7,6,0,0,734,733,1,0,
  	0,0,735,738,1,0,0,0,736,734,1,0,0,0,736,737,1,0,0,0,737,139,1,0,0,0,738,
  	736,1,0,0,0,739,740,7,7,0,0,740,141,1,0,0,0,741,746,3,12,6,0,742,743,
  	5,27,0,0,743,745,3,12,6,0,744,742,1,0,0,0,745,748,1,0,0,0,746,744,1,0,
  	0,0,746,747,1,0,0,0,747,143,1,0,0,0,748,746,1,0,0,0,749,754,3,134,67,
  	0,750,751,5,27,0,0,751,753,3,134,67,0,752,750,1,0,0,0,753,756,1,0,0,0,
  	754,752,1,0,0,0,754,755,1,0,0,0,755,145,1,0,0,0,756,754,1,0,0,0,757,758,
  	5,39,0,0,758,759,5,16,0,0,759,760,3,134,67,0,760,761,5,17,0,0,761,147,
  	1,0,0,0,762,763,5,11,0,0,763,764,5,16,0,0,764,765,3,134,67,0,765,766,
  	5,17,0,0,766,149,1,0,0,0,767,768,5,44,0,0,768,769,5,16,0,0,769,770,3,
  	134,67,0,770,771,5,17,0,0,771,151,1,0,0,0,772,773,5,46,0,0,773,774,5,
  	16,0,0,774,775,3,134,67,0,775,776,5,17,0,0,776,153,1,0,0,0,777,778,5,
  	12,0,0,778,779,5,16,0,0,779,780,3,134,67,0,780,781,5,27,0,0,781,782,3,
  	134,67,0,782,783,5,27,0,0,783,784,3,134,67,0,784,785,5,17,0,0,785,155,
  	1,0,0,0,786,787,5,55,0,0,787,788,5,16,0,0,788,789,3,134,67,0,789,790,
  	5,17,0,0,790,157,1,0,0,0,791,792,5,57,0,0,792,793,5,16,0,0,793,794,3,
  	134,67,0,794,795,5,17,0,0,795,159,1,0,0,0,796,797,5,59,0,0,797,798,5,
  	16,0,0,798,799,3,134,67,0,799,800,5,17,0,0,800,161,1,0,0,0,801,802,5,
  	67,0,0,802,803,5,16,0,0,803,804,3,134,67,0,804,805,5,17,0,0,805,163,1,
  	0,0,0,806,807,5,68,0,0,807,808,5,16,0,0,808,809,3,134,67,0,809,810,5,
  	17,0,0,810,165,1,0,0,0,811,812,5,69,0,0,812,813,5,16,0,0,813,814,3,134,
  	67,0,814,815,5,17,0,0,815,167,1,0,0,0,816,817,5,70,0,0,817,818,5,16,0,
  	0,818,819,3,134,67,0,819,820,5,17,0,0,820,169,1,0,0,0,821,822,5,13,0,
  	0,822,823,5,16,0,0,823,824,3,134,67,0,824,825,5,27,0,0,825,826,3,134,
  	67,0,826,827,5,17,0,0,827,171,1,0,0,0,828,829,5,14,0,0,829,830,5,16,0,
  	0,830,831,3,134,67,0,831,832,5,27,0,0,832,833,3,134,67,0,833,834,5,17,
  	0,0,834,173,1,0,0,0,835,836,5,15,0,0,836,837,5,16,0,0,837,838,3,134,67,
  	0,838,839,5,17,0,0,839,175,1,0,0,0,840,841,5,82,0,0,841,842,3,136,68,
  	0,842,843,5,16,0,0,843,844,3,134,67,0,844,845,5,17,0,0,845,177,1,0,0,
  	0,846,847,5,83,0,0,847,848,5,16,0,0,848,849,3,134,67,0,849,850,5,17,0,
  	0,850,179,1,0,0,0,851,852,5,92,0,0,852,853,5,16,0,0,853,854,3,134,67,
  	0,854,855,5,27,0,0,855,856,3,134,67,0,856,857,5,17,0,0,857,181,1,0,0,
  	0,858,859,5,95,0,0,859,860,5,16,0,0,860,861,3,134,67,0,861,862,5,17,0,
  	0,862,183,1,0,0,0,863,864,5,96,0,0,864,865,5,16,0,0,865,866,3,134,67,
  	0,866,867,5,17,0,0,867,185,1,0,0,0,868,869,5,97,0,0,869,870,5,16,0,0,
  	870,871,3,134,67,0,871,872,5,17,0,0,872,187,1,0,0,0,873,874,5,98,0,0,
  	874,875,5,16,0,0,875,876,3,134,67,0,876,877,5,17,0,0,877,189,1,0,0,0,
  	878,879,5,99,0,0,879,880,5,16,0,0,880,881,3,134,67,0,881,882,5,17,0,0,
  	882,191,1,0,0,0,883,884,5,100,0,0,884,885,5,16,0,0,885,886,3,134,67,0,
  	886,887,5,17,0,0,887,193,1,0,0,0,888,889,5,101,0,0,889,890,5,16,0,0,890,
  	891,3,134,67,0,891,892,5,17,0,0,892,195,1,0,0,0,893,894,5,102,0,0,894,
  	895,5,16,0,0,895,896,3,134,67,0,896,897,5,17,0,0,897,197,1,0,0,0,898,
  	899,5,103,0,0,899,900,5,16,0,0,900,901,3,134,67,0,901,902,5,17,0,0,902,
  	199,1,0,0,0,903,904,5,84,0,0,904,905,5,16,0,0,905,906,3,134,67,0,906,
  	907,5,17,0,0,907,201,1,0,0,0,51,205,213,217,222,229,234,301,310,315,320,
  	324,331,353,361,365,375,380,382,392,400,403,408,437,446,454,463,479,490,
  	511,515,520,528,537,546,550,616,623,638,677,680,683,692,700,708,715,723,
  	726,730,736,746,754
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  basicParserStaticData = std::move(staticData);
}

}

BasicParser::BasicParser(TokenStream *input) : BasicParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

BasicParser::BasicParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  BasicParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *basicParserStaticData->atn, basicParserStaticData->decisionToDFA, basicParserStaticData->sharedContextCache, options);
}

BasicParser::~BasicParser() {
  delete _interpreter;
}

const atn::ATN& BasicParser::getATN() const {
  return *basicParserStaticData->atn;
}

std::string BasicParser::getGrammarFileName() const {
  return "Basic.g4";
}

const std::vector<std::string>& BasicParser::getRuleNames() const {
  return basicParserStaticData->ruleNames;
}

const dfa::Vocabulary& BasicParser::getVocabulary() const {
  return basicParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView BasicParser::getSerializedATN() const {
  return basicParserStaticData->serializedATN;
}


//----------------- ProgContext ------------------------------------------------------------------

BasicParser::ProgContext::ProgContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::ProgContext::EOF() {
  return getToken(BasicParser::EOF, 0);
}

std::vector<BasicParser::LineContext *> BasicParser::ProgContext::line() {
  return getRuleContexts<BasicParser::LineContext>();
}

BasicParser::LineContext* BasicParser::ProgContext::line(size_t i) {
  return getRuleContext<BasicParser::LineContext>(i);
}


size_t BasicParser::ProgContext::getRuleIndex() const {
  return BasicParser::RuleProg;
}


std::any BasicParser::ProgContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitProg(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::ProgContext* BasicParser::prog() {
  ProgContext *_localctx = _tracker.createInstance<ProgContext>(_ctx, getState());
  enterRule(_localctx, 0, BasicParser::RuleProg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(203); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(202);
      line();
      setState(205); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == BasicParser::NUMBER);
    setState(207);
    match(BasicParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LineContext ------------------------------------------------------------------

BasicParser::LineContext::LineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

BasicParser::LinenumberContext* BasicParser::LineContext::linenumber() {
  return getRuleContext<BasicParser::LinenumberContext>(0);
}

std::vector<BasicParser::AmprstmtContext *> BasicParser::LineContext::amprstmt() {
  return getRuleContexts<BasicParser::AmprstmtContext>();
}

BasicParser::AmprstmtContext* BasicParser::LineContext::amprstmt(size_t i) {
  return getRuleContext<BasicParser::AmprstmtContext>(i);
}

tree::TerminalNode* BasicParser::LineContext::COMMENT() {
  return getToken(BasicParser::COMMENT, 0);
}

tree::TerminalNode* BasicParser::LineContext::REM() {
  return getToken(BasicParser::REM, 0);
}

std::vector<tree::TerminalNode *> BasicParser::LineContext::COLON() {
  return getTokens(BasicParser::COLON);
}

tree::TerminalNode* BasicParser::LineContext::COLON(size_t i) {
  return getToken(BasicParser::COLON, i);
}


size_t BasicParser::LineContext::getRuleIndex() const {
  return BasicParser::RuleLine;
}


std::any BasicParser::LineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitLine(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::LineContext* BasicParser::line() {
  LineContext *_localctx = _tracker.createInstance<LineContext>(_ctx, getState());
  enterRule(_localctx, 2, BasicParser::RuleLine);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(209);
    linenumber();
    setState(222);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
    case 1: {
      setState(210);
      amprstmt();
      setState(217);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == BasicParser::COLON) {
        setState(211);
        match(BasicParser::COLON);
        setState(213);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -756694541133675016) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 53962933057812871) != 0)) {
          setState(212);
          amprstmt();
        }
        setState(219);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      setState(220);
      match(BasicParser::COMMENT);
      break;
    }

    case 3: {
      setState(221);
      match(BasicParser::REM);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AmperoperContext ------------------------------------------------------------------

BasicParser::AmperoperContext::AmperoperContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::AmperoperContext::AMPERSAND() {
  return getToken(BasicParser::AMPERSAND, 0);
}


size_t BasicParser::AmperoperContext::getRuleIndex() const {
  return BasicParser::RuleAmperoper;
}


std::any BasicParser::AmperoperContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitAmperoper(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::AmperoperContext* BasicParser::amperoper() {
  AmperoperContext *_localctx = _tracker.createInstance<AmperoperContext>(_ctx, getState());
  enterRule(_localctx, 4, BasicParser::RuleAmperoper);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(224);
    match(BasicParser::AMPERSAND);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LinenumberContext ------------------------------------------------------------------

BasicParser::LinenumberContext::LinenumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::LinenumberContext::NUMBER() {
  return getToken(BasicParser::NUMBER, 0);
}


size_t BasicParser::LinenumberContext::getRuleIndex() const {
  return BasicParser::RuleLinenumber;
}


std::any BasicParser::LinenumberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitLinenumber(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::LinenumberContext* BasicParser::linenumber() {
  LinenumberContext *_localctx = _tracker.createInstance<LinenumberContext>(_ctx, getState());
  enterRule(_localctx, 6, BasicParser::RuleLinenumber);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(226);
    match(BasicParser::NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AmprstmtContext ------------------------------------------------------------------

BasicParser::AmprstmtContext::AmprstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

BasicParser::StatementContext* BasicParser::AmprstmtContext::statement() {
  return getRuleContext<BasicParser::StatementContext>(0);
}

BasicParser::AmperoperContext* BasicParser::AmprstmtContext::amperoper() {
  return getRuleContext<BasicParser::AmperoperContext>(0);
}

tree::TerminalNode* BasicParser::AmprstmtContext::COMMENT() {
  return getToken(BasicParser::COMMENT, 0);
}

tree::TerminalNode* BasicParser::AmprstmtContext::REM() {
  return getToken(BasicParser::REM, 0);
}


size_t BasicParser::AmprstmtContext::getRuleIndex() const {
  return BasicParser::RuleAmprstmt;
}


std::any BasicParser::AmprstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitAmprstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::AmprstmtContext* BasicParser::amprstmt() {
  AmprstmtContext *_localctx = _tracker.createInstance<AmprstmtContext>(_ctx, getState());
  enterRule(_localctx, 8, BasicParser::RuleAmprstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(234);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case BasicParser::RETURN:
      case BasicParser::PRINT:
      case BasicParser::GOTO:
      case BasicParser::GOSUB:
      case BasicParser::IF:
      case BasicParser::NEXT:
      case BasicParser::CLEAR:
      case BasicParser::LIST:
      case BasicParser::RUN:
      case BasicParser::END:
      case BasicParser::LET:
      case BasicParser::FOR:
      case BasicParser::INPUT:
      case BasicParser::DIM:
      case BasicParser::TEXT:
      case BasicParser::HGR:
      case BasicParser::HGR2:
      case BasicParser::CALL:
      case BasicParser::HPLOT:
      case BasicParser::VPLOT:
      case BasicParser::PRNUMBER:
      case BasicParser::INNUMBER:
      case BasicParser::VTAB:
      case BasicParser::HTAB:
      case BasicParser::HOME:
      case BasicParser::ON:
      case BasicParser::PLOT:
      case BasicParser::POKE:
      case BasicParser::STOP:
      case BasicParser::HIMEM:
      case BasicParser::LOMEM:
      case BasicParser::FLASH:
      case BasicParser::INVERSE:
      case BasicParser::NORMAL:
      case BasicParser::ONERR:
      case BasicParser::TRACE:
      case BasicParser::NOTRACE:
      case BasicParser::DATA:
      case BasicParser::WAIT:
      case BasicParser::READ:
      case BasicParser::XDRAW:
      case BasicParser::DRAW:
      case BasicParser::DEF:
      case BasicParser::TAB:
      case BasicParser::SPEED:
      case BasicParser::ROT:
      case BasicParser::SCALE:
      case BasicParser::COLOR:
      case BasicParser::HCOLOR:
      case BasicParser::HLIN:
      case BasicParser::VLIN:
      case BasicParser::POP:
      case BasicParser::SHLOAD:
      case BasicParser::STORE:
      case BasicParser::RECALL:
      case BasicParser::GET:
      case BasicParser::AMPERSAND:
      case BasicParser::GR:
      case BasicParser::RESTORE:
      case BasicParser::SAVE:
      case BasicParser::LOAD:
      case BasicParser::QUESTION:
      case BasicParser::INCLUDE:
      case BasicParser::CLS:
      case BasicParser::LETTERS: {
        enterOuterAlt(_localctx, 1);
        setState(229);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx)) {
        case 1: {
          setState(228);
          amperoper();
          break;
        }

        default:
          break;
        }
        setState(231);
        statement();
        break;
      }

      case BasicParser::COMMENT: {
        enterOuterAlt(_localctx, 2);
        setState(232);
        match(BasicParser::COMMENT);
        break;
      }

      case BasicParser::REM: {
        enterOuterAlt(_localctx, 3);
        setState(233);
        match(BasicParser::REM);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

BasicParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::StatementContext::CLS() {
  return getToken(BasicParser::CLS, 0);
}

tree::TerminalNode* BasicParser::StatementContext::LOAD() {
  return getToken(BasicParser::LOAD, 0);
}

tree::TerminalNode* BasicParser::StatementContext::SAVE() {
  return getToken(BasicParser::SAVE, 0);
}

tree::TerminalNode* BasicParser::StatementContext::TRACE() {
  return getToken(BasicParser::TRACE, 0);
}

tree::TerminalNode* BasicParser::StatementContext::NOTRACE() {
  return getToken(BasicParser::NOTRACE, 0);
}

tree::TerminalNode* BasicParser::StatementContext::FLASH() {
  return getToken(BasicParser::FLASH, 0);
}

tree::TerminalNode* BasicParser::StatementContext::INVERSE() {
  return getToken(BasicParser::INVERSE, 0);
}

tree::TerminalNode* BasicParser::StatementContext::GR() {
  return getToken(BasicParser::GR, 0);
}

tree::TerminalNode* BasicParser::StatementContext::NORMAL() {
  return getToken(BasicParser::NORMAL, 0);
}

tree::TerminalNode* BasicParser::StatementContext::SHLOAD() {
  return getToken(BasicParser::SHLOAD, 0);
}

tree::TerminalNode* BasicParser::StatementContext::CLEAR() {
  return getToken(BasicParser::CLEAR, 0);
}

tree::TerminalNode* BasicParser::StatementContext::RUN() {
  return getToken(BasicParser::RUN, 0);
}

tree::TerminalNode* BasicParser::StatementContext::STOP() {
  return getToken(BasicParser::STOP, 0);
}

tree::TerminalNode* BasicParser::StatementContext::TEXT() {
  return getToken(BasicParser::TEXT, 0);
}

tree::TerminalNode* BasicParser::StatementContext::HOME() {
  return getToken(BasicParser::HOME, 0);
}

tree::TerminalNode* BasicParser::StatementContext::HGR() {
  return getToken(BasicParser::HGR, 0);
}

tree::TerminalNode* BasicParser::StatementContext::HGR2() {
  return getToken(BasicParser::HGR2, 0);
}

BasicParser::EndstmtContext* BasicParser::StatementContext::endstmt() {
  return getRuleContext<BasicParser::EndstmtContext>(0);
}

BasicParser::ReturnstmtContext* BasicParser::StatementContext::returnstmt() {
  return getRuleContext<BasicParser::ReturnstmtContext>(0);
}

BasicParser::RestorestmtContext* BasicParser::StatementContext::restorestmt() {
  return getRuleContext<BasicParser::RestorestmtContext>(0);
}

BasicParser::AmptstmtContext* BasicParser::StatementContext::amptstmt() {
  return getRuleContext<BasicParser::AmptstmtContext>(0);
}

BasicParser::PopstmtContext* BasicParser::StatementContext::popstmt() {
  return getRuleContext<BasicParser::PopstmtContext>(0);
}

BasicParser::ListstmtContext* BasicParser::StatementContext::liststmt() {
  return getRuleContext<BasicParser::ListstmtContext>(0);
}

BasicParser::StorestmtContext* BasicParser::StatementContext::storestmt() {
  return getRuleContext<BasicParser::StorestmtContext>(0);
}

BasicParser::GetstmtContext* BasicParser::StatementContext::getstmt() {
  return getRuleContext<BasicParser::GetstmtContext>(0);
}

BasicParser::RecallstmtContext* BasicParser::StatementContext::recallstmt() {
  return getRuleContext<BasicParser::RecallstmtContext>(0);
}

BasicParser::NextstmtContext* BasicParser::StatementContext::nextstmt() {
  return getRuleContext<BasicParser::NextstmtContext>(0);
}

BasicParser::InstmtContext* BasicParser::StatementContext::instmt() {
  return getRuleContext<BasicParser::InstmtContext>(0);
}

BasicParser::PrstmtContext* BasicParser::StatementContext::prstmt() {
  return getRuleContext<BasicParser::PrstmtContext>(0);
}

BasicParser::OnerrstmtContext* BasicParser::StatementContext::onerrstmt() {
  return getRuleContext<BasicParser::OnerrstmtContext>(0);
}

BasicParser::HlinstmtContext* BasicParser::StatementContext::hlinstmt() {
  return getRuleContext<BasicParser::HlinstmtContext>(0);
}

BasicParser::VlinstmtContext* BasicParser::StatementContext::vlinstmt() {
  return getRuleContext<BasicParser::VlinstmtContext>(0);
}

BasicParser::ColorstmtContext* BasicParser::StatementContext::colorstmt() {
  return getRuleContext<BasicParser::ColorstmtContext>(0);
}

BasicParser::SpeedstmtContext* BasicParser::StatementContext::speedstmt() {
  return getRuleContext<BasicParser::SpeedstmtContext>(0);
}

BasicParser::ScalestmtContext* BasicParser::StatementContext::scalestmt() {
  return getRuleContext<BasicParser::ScalestmtContext>(0);
}

BasicParser::RotstmtContext* BasicParser::StatementContext::rotstmt() {
  return getRuleContext<BasicParser::RotstmtContext>(0);
}

BasicParser::HcolorstmtContext* BasicParser::StatementContext::hcolorstmt() {
  return getRuleContext<BasicParser::HcolorstmtContext>(0);
}

BasicParser::HimemstmtContext* BasicParser::StatementContext::himemstmt() {
  return getRuleContext<BasicParser::HimemstmtContext>(0);
}

BasicParser::LomemstmtContext* BasicParser::StatementContext::lomemstmt() {
  return getRuleContext<BasicParser::LomemstmtContext>(0);
}

BasicParser::Printstmt1Context* BasicParser::StatementContext::printstmt1() {
  return getRuleContext<BasicParser::Printstmt1Context>(0);
}

BasicParser::PokestmtContext* BasicParser::StatementContext::pokestmt() {
  return getRuleContext<BasicParser::PokestmtContext>(0);
}

BasicParser::PlotstmtContext* BasicParser::StatementContext::plotstmt() {
  return getRuleContext<BasicParser::PlotstmtContext>(0);
}

BasicParser::OngotostmtContext* BasicParser::StatementContext::ongotostmt() {
  return getRuleContext<BasicParser::OngotostmtContext>(0);
}

BasicParser::OngosubstmtContext* BasicParser::StatementContext::ongosubstmt() {
  return getRuleContext<BasicParser::OngosubstmtContext>(0);
}

BasicParser::IfstmtContext* BasicParser::StatementContext::ifstmt() {
  return getRuleContext<BasicParser::IfstmtContext>(0);
}

BasicParser::Forstmt1Context* BasicParser::StatementContext::forstmt1() {
  return getRuleContext<BasicParser::Forstmt1Context>(0);
}

BasicParser::Forstmt2Context* BasicParser::StatementContext::forstmt2() {
  return getRuleContext<BasicParser::Forstmt2Context>(0);
}

BasicParser::InputstmtContext* BasicParser::StatementContext::inputstmt() {
  return getRuleContext<BasicParser::InputstmtContext>(0);
}

BasicParser::TabstmtContext* BasicParser::StatementContext::tabstmt() {
  return getRuleContext<BasicParser::TabstmtContext>(0);
}

BasicParser::DimstmtContext* BasicParser::StatementContext::dimstmt() {
  return getRuleContext<BasicParser::DimstmtContext>(0);
}

BasicParser::GotostmtContext* BasicParser::StatementContext::gotostmt() {
  return getRuleContext<BasicParser::GotostmtContext>(0);
}

BasicParser::GosubstmtContext* BasicParser::StatementContext::gosubstmt() {
  return getRuleContext<BasicParser::GosubstmtContext>(0);
}

BasicParser::CallstmtContext* BasicParser::StatementContext::callstmt() {
  return getRuleContext<BasicParser::CallstmtContext>(0);
}

BasicParser::ReadstmtContext* BasicParser::StatementContext::readstmt() {
  return getRuleContext<BasicParser::ReadstmtContext>(0);
}

BasicParser::HplotstmtContext* BasicParser::StatementContext::hplotstmt() {
  return getRuleContext<BasicParser::HplotstmtContext>(0);
}

BasicParser::VplotstmtContext* BasicParser::StatementContext::vplotstmt() {
  return getRuleContext<BasicParser::VplotstmtContext>(0);
}

BasicParser::VtabstmntContext* BasicParser::StatementContext::vtabstmnt() {
  return getRuleContext<BasicParser::VtabstmntContext>(0);
}

BasicParser::HtabstmntContext* BasicParser::StatementContext::htabstmnt() {
  return getRuleContext<BasicParser::HtabstmntContext>(0);
}

BasicParser::WaitstmtContext* BasicParser::StatementContext::waitstmt() {
  return getRuleContext<BasicParser::WaitstmtContext>(0);
}

BasicParser::DatastmtContext* BasicParser::StatementContext::datastmt() {
  return getRuleContext<BasicParser::DatastmtContext>(0);
}

BasicParser::XdrawstmtContext* BasicParser::StatementContext::xdrawstmt() {
  return getRuleContext<BasicParser::XdrawstmtContext>(0);
}

BasicParser::DrawstmtContext* BasicParser::StatementContext::drawstmt() {
  return getRuleContext<BasicParser::DrawstmtContext>(0);
}

BasicParser::DefstmtContext* BasicParser::StatementContext::defstmt() {
  return getRuleContext<BasicParser::DefstmtContext>(0);
}

BasicParser::LetstmtContext* BasicParser::StatementContext::letstmt() {
  return getRuleContext<BasicParser::LetstmtContext>(0);
}

BasicParser::IncludestmtContext* BasicParser::StatementContext::includestmt() {
  return getRuleContext<BasicParser::IncludestmtContext>(0);
}


size_t BasicParser::StatementContext::getRuleIndex() const {
  return BasicParser::RuleStatement;
}


std::any BasicParser::StatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitStatement(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::StatementContext* BasicParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 10, BasicParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(301);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(236);
      match(BasicParser::CLS);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(237);
      match(BasicParser::LOAD);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(238);
      match(BasicParser::SAVE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(239);
      match(BasicParser::TRACE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(240);
      match(BasicParser::NOTRACE);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(241);
      match(BasicParser::FLASH);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(242);
      match(BasicParser::INVERSE);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(243);
      match(BasicParser::GR);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(244);
      match(BasicParser::NORMAL);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(245);
      match(BasicParser::SHLOAD);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(246);
      match(BasicParser::CLEAR);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(247);
      match(BasicParser::RUN);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(248);
      match(BasicParser::STOP);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(249);
      match(BasicParser::TEXT);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(250);
      match(BasicParser::HOME);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(251);
      match(BasicParser::HGR);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(252);
      match(BasicParser::HGR2);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(253);
      endstmt();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(254);
      returnstmt();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(255);
      restorestmt();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(256);
      amptstmt();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(257);
      popstmt();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(258);
      liststmt();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(259);
      storestmt();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(260);
      getstmt();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(261);
      recallstmt();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(262);
      nextstmt();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(263);
      instmt();
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(264);
      prstmt();
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(265);
      onerrstmt();
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(266);
      hlinstmt();
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(267);
      vlinstmt();
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(268);
      colorstmt();
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(269);
      speedstmt();
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(270);
      scalestmt();
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(271);
      rotstmt();
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(272);
      hcolorstmt();
      break;
    }

    case 38: {
      enterOuterAlt(_localctx, 38);
      setState(273);
      himemstmt();
      break;
    }

    case 39: {
      enterOuterAlt(_localctx, 39);
      setState(274);
      lomemstmt();
      break;
    }

    case 40: {
      enterOuterAlt(_localctx, 40);
      setState(275);
      printstmt1();
      break;
    }

    case 41: {
      enterOuterAlt(_localctx, 41);
      setState(276);
      pokestmt();
      break;
    }

    case 42: {
      enterOuterAlt(_localctx, 42);
      setState(277);
      plotstmt();
      break;
    }

    case 43: {
      enterOuterAlt(_localctx, 43);
      setState(278);
      ongotostmt();
      break;
    }

    case 44: {
      enterOuterAlt(_localctx, 44);
      setState(279);
      ongosubstmt();
      break;
    }

    case 45: {
      enterOuterAlt(_localctx, 45);
      setState(280);
      ifstmt();
      break;
    }

    case 46: {
      enterOuterAlt(_localctx, 46);
      setState(281);
      forstmt1();
      break;
    }

    case 47: {
      enterOuterAlt(_localctx, 47);
      setState(282);
      forstmt2();
      break;
    }

    case 48: {
      enterOuterAlt(_localctx, 48);
      setState(283);
      inputstmt();
      break;
    }

    case 49: {
      enterOuterAlt(_localctx, 49);
      setState(284);
      tabstmt();
      break;
    }

    case 50: {
      enterOuterAlt(_localctx, 50);
      setState(285);
      dimstmt();
      break;
    }

    case 51: {
      enterOuterAlt(_localctx, 51);
      setState(286);
      gotostmt();
      break;
    }

    case 52: {
      enterOuterAlt(_localctx, 52);
      setState(287);
      gosubstmt();
      break;
    }

    case 53: {
      enterOuterAlt(_localctx, 53);
      setState(288);
      callstmt();
      break;
    }

    case 54: {
      enterOuterAlt(_localctx, 54);
      setState(289);
      readstmt();
      break;
    }

    case 55: {
      enterOuterAlt(_localctx, 55);
      setState(290);
      hplotstmt();
      break;
    }

    case 56: {
      enterOuterAlt(_localctx, 56);
      setState(291);
      vplotstmt();
      break;
    }

    case 57: {
      enterOuterAlt(_localctx, 57);
      setState(292);
      vtabstmnt();
      break;
    }

    case 58: {
      enterOuterAlt(_localctx, 58);
      setState(293);
      htabstmnt();
      break;
    }

    case 59: {
      enterOuterAlt(_localctx, 59);
      setState(294);
      waitstmt();
      break;
    }

    case 60: {
      enterOuterAlt(_localctx, 60);
      setState(295);
      datastmt();
      break;
    }

    case 61: {
      enterOuterAlt(_localctx, 61);
      setState(296);
      xdrawstmt();
      break;
    }

    case 62: {
      enterOuterAlt(_localctx, 62);
      setState(297);
      drawstmt();
      break;
    }

    case 63: {
      enterOuterAlt(_localctx, 63);
      setState(298);
      defstmt();
      break;
    }

    case 64: {
      enterOuterAlt(_localctx, 64);
      setState(299);
      letstmt();
      break;
    }

    case 65: {
      enterOuterAlt(_localctx, 65);
      setState(300);
      includestmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VardeclContext ------------------------------------------------------------------

BasicParser::VardeclContext::VardeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

BasicParser::Var_Context* BasicParser::VardeclContext::var_() {
  return getRuleContext<BasicParser::Var_Context>(0);
}

std::vector<tree::TerminalNode *> BasicParser::VardeclContext::LPAREN() {
  return getTokens(BasicParser::LPAREN);
}

tree::TerminalNode* BasicParser::VardeclContext::LPAREN(size_t i) {
  return getToken(BasicParser::LPAREN, i);
}

std::vector<BasicParser::ExprlistContext *> BasicParser::VardeclContext::exprlist() {
  return getRuleContexts<BasicParser::ExprlistContext>();
}

BasicParser::ExprlistContext* BasicParser::VardeclContext::exprlist(size_t i) {
  return getRuleContext<BasicParser::ExprlistContext>(i);
}

std::vector<tree::TerminalNode *> BasicParser::VardeclContext::RPAREN() {
  return getTokens(BasicParser::RPAREN);
}

tree::TerminalNode* BasicParser::VardeclContext::RPAREN(size_t i) {
  return getToken(BasicParser::RPAREN, i);
}


size_t BasicParser::VardeclContext::getRuleIndex() const {
  return BasicParser::RuleVardecl;
}


std::any BasicParser::VardeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitVardecl(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::VardeclContext* BasicParser::vardecl() {
  VardeclContext *_localctx = _tracker.createInstance<VardeclContext>(_ctx, getState());
  enterRule(_localctx, 12, BasicParser::RuleVardecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(303);
    var_();
    setState(310);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == BasicParser::LPAREN) {
      setState(304);
      match(BasicParser::LPAREN);
      setState(305);
      exprlist();
      setState(306);
      match(BasicParser::RPAREN);
      setState(312);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Printstmt1Context ------------------------------------------------------------------

BasicParser::Printstmt1Context::Printstmt1Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::Printstmt1Context::PRINT() {
  return getToken(BasicParser::PRINT, 0);
}

tree::TerminalNode* BasicParser::Printstmt1Context::QUESTION() {
  return getToken(BasicParser::QUESTION, 0);
}

BasicParser::PrintlistContext* BasicParser::Printstmt1Context::printlist() {
  return getRuleContext<BasicParser::PrintlistContext>(0);
}


size_t BasicParser::Printstmt1Context::getRuleIndex() const {
  return BasicParser::RulePrintstmt1;
}


std::any BasicParser::Printstmt1Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitPrintstmt1(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::Printstmt1Context* BasicParser::printstmt1() {
  Printstmt1Context *_localctx = _tracker.createInstance<Printstmt1Context>(_ctx, getState());
  enterRule(_localctx, 14, BasicParser::RulePrintstmt1);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(313);
    _la = _input->LA(1);
    if (!(_la == BasicParser::PRINT || _la == BasicParser::QUESTION)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(315);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
    case 1: {
      setState(314);
      printlist();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrintlistContext ------------------------------------------------------------------

BasicParser::PrintlistContext::PrintlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<BasicParser::ExpressionContext *> BasicParser::PrintlistContext::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::PrintlistContext::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> BasicParser::PrintlistContext::COMMA() {
  return getTokens(BasicParser::COMMA);
}

tree::TerminalNode* BasicParser::PrintlistContext::COMMA(size_t i) {
  return getToken(BasicParser::COMMA, i);
}

std::vector<tree::TerminalNode *> BasicParser::PrintlistContext::SEMICOLON() {
  return getTokens(BasicParser::SEMICOLON);
}

tree::TerminalNode* BasicParser::PrintlistContext::SEMICOLON(size_t i) {
  return getToken(BasicParser::SEMICOLON, i);
}


size_t BasicParser::PrintlistContext::getRuleIndex() const {
  return BasicParser::RulePrintlist;
}


std::any BasicParser::PrintlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitPrintlist(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::PrintlistContext* BasicParser::printlist() {
  PrintlistContext *_localctx = _tracker.createInstance<PrintlistContext>(_ctx, getState());
  enterRule(_localctx, 16, BasicParser::RulePrintlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(317);
    expression();
    setState(324);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == BasicParser::COMMA

    || _la == BasicParser::SEMICOLON) {
      setState(318);
      _la = _input->LA(1);
      if (!(_la == BasicParser::COMMA

      || _la == BasicParser::SEMICOLON)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(320);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
      case 1: {
        setState(319);
        expression();
        break;
      }

      default:
        break;
      }
      setState(326);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetstmtContext ------------------------------------------------------------------

BasicParser::GetstmtContext::GetstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::GetstmtContext::GET() {
  return getToken(BasicParser::GET, 0);
}

BasicParser::ExprlistContext* BasicParser::GetstmtContext::exprlist() {
  return getRuleContext<BasicParser::ExprlistContext>(0);
}


size_t BasicParser::GetstmtContext::getRuleIndex() const {
  return BasicParser::RuleGetstmt;
}


std::any BasicParser::GetstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitGetstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::GetstmtContext* BasicParser::getstmt() {
  GetstmtContext *_localctx = _tracker.createInstance<GetstmtContext>(_ctx, getState());
  enterRule(_localctx, 18, BasicParser::RuleGetstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(327);
    match(BasicParser::GET);
    setState(328);
    exprlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LetstmtContext ------------------------------------------------------------------

BasicParser::LetstmtContext::LetstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

BasicParser::VariableassignmentContext* BasicParser::LetstmtContext::variableassignment() {
  return getRuleContext<BasicParser::VariableassignmentContext>(0);
}

tree::TerminalNode* BasicParser::LetstmtContext::LET() {
  return getToken(BasicParser::LET, 0);
}


size_t BasicParser::LetstmtContext::getRuleIndex() const {
  return BasicParser::RuleLetstmt;
}


std::any BasicParser::LetstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitLetstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::LetstmtContext* BasicParser::letstmt() {
  LetstmtContext *_localctx = _tracker.createInstance<LetstmtContext>(_ctx, getState());
  enterRule(_localctx, 20, BasicParser::RuleLetstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(331);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == BasicParser::LET) {
      setState(330);
      match(BasicParser::LET);
    }
    setState(333);
    variableassignment();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableassignmentContext ------------------------------------------------------------------

BasicParser::VariableassignmentContext::VariableassignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

BasicParser::VardeclContext* BasicParser::VariableassignmentContext::vardecl() {
  return getRuleContext<BasicParser::VardeclContext>(0);
}

tree::TerminalNode* BasicParser::VariableassignmentContext::EQ() {
  return getToken(BasicParser::EQ, 0);
}

BasicParser::ExprlistContext* BasicParser::VariableassignmentContext::exprlist() {
  return getRuleContext<BasicParser::ExprlistContext>(0);
}


size_t BasicParser::VariableassignmentContext::getRuleIndex() const {
  return BasicParser::RuleVariableassignment;
}


std::any BasicParser::VariableassignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitVariableassignment(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::VariableassignmentContext* BasicParser::variableassignment() {
  VariableassignmentContext *_localctx = _tracker.createInstance<VariableassignmentContext>(_ctx, getState());
  enterRule(_localctx, 22, BasicParser::RuleVariableassignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(335);
    vardecl();
    setState(336);
    match(BasicParser::EQ);
    setState(337);
    exprlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelopContext ------------------------------------------------------------------

BasicParser::RelopContext::RelopContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::RelopContext::GTE() {
  return getToken(BasicParser::GTE, 0);
}

tree::TerminalNode* BasicParser::RelopContext::GT() {
  return getToken(BasicParser::GT, 0);
}

tree::TerminalNode* BasicParser::RelopContext::EQ() {
  return getToken(BasicParser::EQ, 0);
}

tree::TerminalNode* BasicParser::RelopContext::LTE() {
  return getToken(BasicParser::LTE, 0);
}

tree::TerminalNode* BasicParser::RelopContext::LT() {
  return getToken(BasicParser::LT, 0);
}

BasicParser::NeqContext* BasicParser::RelopContext::neq() {
  return getRuleContext<BasicParser::NeqContext>(0);
}


size_t BasicParser::RelopContext::getRuleIndex() const {
  return BasicParser::RuleRelop;
}


std::any BasicParser::RelopContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitRelop(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::RelopContext* BasicParser::relop() {
  RelopContext *_localctx = _tracker.createInstance<RelopContext>(_ctx, getState());
  enterRule(_localctx, 24, BasicParser::RuleRelop);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(353);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(339);
      match(BasicParser::GTE);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(340);
      match(BasicParser::GT);
      setState(341);
      match(BasicParser::EQ);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(342);
      match(BasicParser::EQ);
      setState(343);
      match(BasicParser::GT);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(344);
      match(BasicParser::LTE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(345);
      match(BasicParser::LT);
      setState(346);
      match(BasicParser::EQ);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(347);
      match(BasicParser::EQ);
      setState(348);
      match(BasicParser::LT);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(349);
      neq();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(350);
      match(BasicParser::EQ);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(351);
      match(BasicParser::GT);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(352);
      match(BasicParser::LT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NeqContext ------------------------------------------------------------------

BasicParser::NeqContext::NeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::NeqContext::LT() {
  return getToken(BasicParser::LT, 0);
}

tree::TerminalNode* BasicParser::NeqContext::GT() {
  return getToken(BasicParser::GT, 0);
}


size_t BasicParser::NeqContext::getRuleIndex() const {
  return BasicParser::RuleNeq;
}


std::any BasicParser::NeqContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitNeq(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::NeqContext* BasicParser::neq() {
  NeqContext *_localctx = _tracker.createInstance<NeqContext>(_ctx, getState());
  enterRule(_localctx, 26, BasicParser::RuleNeq);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(355);
    match(BasicParser::LT);
    setState(356);
    match(BasicParser::GT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfstmtContext ------------------------------------------------------------------

BasicParser::IfstmtContext::IfstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::IfstmtContext::IF() {
  return getToken(BasicParser::IF, 0);
}

BasicParser::ExpressionContext* BasicParser::IfstmtContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

BasicParser::StatementContext* BasicParser::IfstmtContext::statement() {
  return getRuleContext<BasicParser::StatementContext>(0);
}

BasicParser::LinenumberContext* BasicParser::IfstmtContext::linenumber() {
  return getRuleContext<BasicParser::LinenumberContext>(0);
}

tree::TerminalNode* BasicParser::IfstmtContext::THEN() {
  return getToken(BasicParser::THEN, 0);
}


size_t BasicParser::IfstmtContext::getRuleIndex() const {
  return BasicParser::RuleIfstmt;
}


std::any BasicParser::IfstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitIfstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::IfstmtContext* BasicParser::ifstmt() {
  IfstmtContext *_localctx = _tracker.createInstance<IfstmtContext>(_ctx, getState());
  enterRule(_localctx, 28, BasicParser::RuleIfstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(358);
    match(BasicParser::IF);
    setState(359);
    expression();
    setState(361);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == BasicParser::THEN) {
      setState(360);
      match(BasicParser::THEN);
    }
    setState(365);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case BasicParser::RETURN:
      case BasicParser::PRINT:
      case BasicParser::GOTO:
      case BasicParser::GOSUB:
      case BasicParser::IF:
      case BasicParser::NEXT:
      case BasicParser::CLEAR:
      case BasicParser::LIST:
      case BasicParser::RUN:
      case BasicParser::END:
      case BasicParser::LET:
      case BasicParser::FOR:
      case BasicParser::INPUT:
      case BasicParser::DIM:
      case BasicParser::TEXT:
      case BasicParser::HGR:
      case BasicParser::HGR2:
      case BasicParser::CALL:
      case BasicParser::HPLOT:
      case BasicParser::VPLOT:
      case BasicParser::PRNUMBER:
      case BasicParser::INNUMBER:
      case BasicParser::VTAB:
      case BasicParser::HTAB:
      case BasicParser::HOME:
      case BasicParser::ON:
      case BasicParser::PLOT:
      case BasicParser::POKE:
      case BasicParser::STOP:
      case BasicParser::HIMEM:
      case BasicParser::LOMEM:
      case BasicParser::FLASH:
      case BasicParser::INVERSE:
      case BasicParser::NORMAL:
      case BasicParser::ONERR:
      case BasicParser::TRACE:
      case BasicParser::NOTRACE:
      case BasicParser::DATA:
      case BasicParser::WAIT:
      case BasicParser::READ:
      case BasicParser::XDRAW:
      case BasicParser::DRAW:
      case BasicParser::DEF:
      case BasicParser::TAB:
      case BasicParser::SPEED:
      case BasicParser::ROT:
      case BasicParser::SCALE:
      case BasicParser::COLOR:
      case BasicParser::HCOLOR:
      case BasicParser::HLIN:
      case BasicParser::VLIN:
      case BasicParser::POP:
      case BasicParser::SHLOAD:
      case BasicParser::STORE:
      case BasicParser::RECALL:
      case BasicParser::GET:
      case BasicParser::AMPERSAND:
      case BasicParser::GR:
      case BasicParser::RESTORE:
      case BasicParser::SAVE:
      case BasicParser::LOAD:
      case BasicParser::QUESTION:
      case BasicParser::INCLUDE:
      case BasicParser::CLS:
      case BasicParser::LETTERS: {
        setState(363);
        statement();
        break;
      }

      case BasicParser::NUMBER: {
        setState(364);
        linenumber();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Forstmt1Context ------------------------------------------------------------------

BasicParser::Forstmt1Context::Forstmt1Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::Forstmt1Context::FOR() {
  return getToken(BasicParser::FOR, 0);
}

std::vector<BasicParser::VardeclContext *> BasicParser::Forstmt1Context::vardecl() {
  return getRuleContexts<BasicParser::VardeclContext>();
}

BasicParser::VardeclContext* BasicParser::Forstmt1Context::vardecl(size_t i) {
  return getRuleContext<BasicParser::VardeclContext>(i);
}

tree::TerminalNode* BasicParser::Forstmt1Context::EQ() {
  return getToken(BasicParser::EQ, 0);
}

std::vector<BasicParser::ExpressionContext *> BasicParser::Forstmt1Context::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::Forstmt1Context::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

tree::TerminalNode* BasicParser::Forstmt1Context::TO() {
  return getToken(BasicParser::TO, 0);
}

tree::TerminalNode* BasicParser::Forstmt1Context::STEP() {
  return getToken(BasicParser::STEP, 0);
}

BasicParser::StatementContext* BasicParser::Forstmt1Context::statement() {
  return getRuleContext<BasicParser::StatementContext>(0);
}

tree::TerminalNode* BasicParser::Forstmt1Context::NEXT() {
  return getToken(BasicParser::NEXT, 0);
}


size_t BasicParser::Forstmt1Context::getRuleIndex() const {
  return BasicParser::RuleForstmt1;
}


std::any BasicParser::Forstmt1Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitForstmt1(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::Forstmt1Context* BasicParser::forstmt1() {
  Forstmt1Context *_localctx = _tracker.createInstance<Forstmt1Context>(_ctx, getState());
  enterRule(_localctx, 30, BasicParser::RuleForstmt1);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(367);
    match(BasicParser::FOR);
    setState(368);
    vardecl();
    setState(369);
    match(BasicParser::EQ);
    setState(370);
    expression();
    setState(371);
    match(BasicParser::TO);
    setState(372);
    expression();
    setState(375);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == BasicParser::STEP) {
      setState(373);
      match(BasicParser::STEP);
      setState(374);
      expression();
    }
    setState(382);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
    case 1: {
      setState(377);
      statement();
      setState(378);
      match(BasicParser::NEXT);
      setState(380);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == BasicParser::LETTERS) {
        setState(379);
        vardecl();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Forstmt2Context ------------------------------------------------------------------

BasicParser::Forstmt2Context::Forstmt2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::Forstmt2Context::FOR() {
  return getToken(BasicParser::FOR, 0);
}

BasicParser::VardeclContext* BasicParser::Forstmt2Context::vardecl() {
  return getRuleContext<BasicParser::VardeclContext>(0);
}

tree::TerminalNode* BasicParser::Forstmt2Context::EQ() {
  return getToken(BasicParser::EQ, 0);
}

std::vector<BasicParser::ExpressionContext *> BasicParser::Forstmt2Context::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::Forstmt2Context::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

tree::TerminalNode* BasicParser::Forstmt2Context::TO() {
  return getToken(BasicParser::TO, 0);
}

tree::TerminalNode* BasicParser::Forstmt2Context::STEP() {
  return getToken(BasicParser::STEP, 0);
}


size_t BasicParser::Forstmt2Context::getRuleIndex() const {
  return BasicParser::RuleForstmt2;
}


std::any BasicParser::Forstmt2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitForstmt2(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::Forstmt2Context* BasicParser::forstmt2() {
  Forstmt2Context *_localctx = _tracker.createInstance<Forstmt2Context>(_ctx, getState());
  enterRule(_localctx, 32, BasicParser::RuleForstmt2);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(384);
    match(BasicParser::FOR);
    setState(385);
    vardecl();
    setState(386);
    match(BasicParser::EQ);
    setState(387);
    expression();
    setState(388);
    match(BasicParser::TO);
    setState(389);
    expression();
    setState(392);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == BasicParser::STEP) {
      setState(390);
      match(BasicParser::STEP);
      setState(391);
      expression();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NextstmtContext ------------------------------------------------------------------

BasicParser::NextstmtContext::NextstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::NextstmtContext::NEXT() {
  return getToken(BasicParser::NEXT, 0);
}

std::vector<BasicParser::VardeclContext *> BasicParser::NextstmtContext::vardecl() {
  return getRuleContexts<BasicParser::VardeclContext>();
}

BasicParser::VardeclContext* BasicParser::NextstmtContext::vardecl(size_t i) {
  return getRuleContext<BasicParser::VardeclContext>(i);
}

std::vector<tree::TerminalNode *> BasicParser::NextstmtContext::COMMA() {
  return getTokens(BasicParser::COMMA);
}

tree::TerminalNode* BasicParser::NextstmtContext::COMMA(size_t i) {
  return getToken(BasicParser::COMMA, i);
}


size_t BasicParser::NextstmtContext::getRuleIndex() const {
  return BasicParser::RuleNextstmt;
}


std::any BasicParser::NextstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitNextstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::NextstmtContext* BasicParser::nextstmt() {
  NextstmtContext *_localctx = _tracker.createInstance<NextstmtContext>(_ctx, getState());
  enterRule(_localctx, 34, BasicParser::RuleNextstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(394);
    match(BasicParser::NEXT);
    setState(403);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == BasicParser::LETTERS) {
      setState(395);
      vardecl();
      setState(400);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == BasicParser::COMMA) {
        setState(396);
        match(BasicParser::COMMA);
        setState(397);
        vardecl();
        setState(402);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InputstmtContext ------------------------------------------------------------------

BasicParser::InputstmtContext::InputstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::InputstmtContext::INPUT() {
  return getToken(BasicParser::INPUT, 0);
}

BasicParser::VarlistContext* BasicParser::InputstmtContext::varlist() {
  return getRuleContext<BasicParser::VarlistContext>(0);
}

tree::TerminalNode* BasicParser::InputstmtContext::STRINGLITERAL() {
  return getToken(BasicParser::STRINGLITERAL, 0);
}

tree::TerminalNode* BasicParser::InputstmtContext::COMMA() {
  return getToken(BasicParser::COMMA, 0);
}

tree::TerminalNode* BasicParser::InputstmtContext::SEMICOLON() {
  return getToken(BasicParser::SEMICOLON, 0);
}


size_t BasicParser::InputstmtContext::getRuleIndex() const {
  return BasicParser::RuleInputstmt;
}


std::any BasicParser::InputstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitInputstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::InputstmtContext* BasicParser::inputstmt() {
  InputstmtContext *_localctx = _tracker.createInstance<InputstmtContext>(_ctx, getState());
  enterRule(_localctx, 36, BasicParser::RuleInputstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(405);
    match(BasicParser::INPUT);
    setState(408);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == BasicParser::STRINGLITERAL) {
      setState(406);
      match(BasicParser::STRINGLITERAL);
      setState(407);
      _la = _input->LA(1);
      if (!(_la == BasicParser::COMMA

      || _la == BasicParser::SEMICOLON)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(410);
    varlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReadstmtContext ------------------------------------------------------------------

BasicParser::ReadstmtContext::ReadstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::ReadstmtContext::READ() {
  return getToken(BasicParser::READ, 0);
}

BasicParser::VarlistContext* BasicParser::ReadstmtContext::varlist() {
  return getRuleContext<BasicParser::VarlistContext>(0);
}


size_t BasicParser::ReadstmtContext::getRuleIndex() const {
  return BasicParser::RuleReadstmt;
}


std::any BasicParser::ReadstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitReadstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::ReadstmtContext* BasicParser::readstmt() {
  ReadstmtContext *_localctx = _tracker.createInstance<ReadstmtContext>(_ctx, getState());
  enterRule(_localctx, 38, BasicParser::RuleReadstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(412);
    match(BasicParser::READ);
    setState(413);
    varlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DimstmtContext ------------------------------------------------------------------

BasicParser::DimstmtContext::DimstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::DimstmtContext::DIM() {
  return getToken(BasicParser::DIM, 0);
}

BasicParser::VarlistContext* BasicParser::DimstmtContext::varlist() {
  return getRuleContext<BasicParser::VarlistContext>(0);
}


size_t BasicParser::DimstmtContext::getRuleIndex() const {
  return BasicParser::RuleDimstmt;
}


std::any BasicParser::DimstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitDimstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::DimstmtContext* BasicParser::dimstmt() {
  DimstmtContext *_localctx = _tracker.createInstance<DimstmtContext>(_ctx, getState());
  enterRule(_localctx, 40, BasicParser::RuleDimstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(415);
    match(BasicParser::DIM);
    setState(416);
    varlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GotostmtContext ------------------------------------------------------------------

BasicParser::GotostmtContext::GotostmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::GotostmtContext::GOTO() {
  return getToken(BasicParser::GOTO, 0);
}

BasicParser::LinenumberContext* BasicParser::GotostmtContext::linenumber() {
  return getRuleContext<BasicParser::LinenumberContext>(0);
}


size_t BasicParser::GotostmtContext::getRuleIndex() const {
  return BasicParser::RuleGotostmt;
}


std::any BasicParser::GotostmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitGotostmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::GotostmtContext* BasicParser::gotostmt() {
  GotostmtContext *_localctx = _tracker.createInstance<GotostmtContext>(_ctx, getState());
  enterRule(_localctx, 42, BasicParser::RuleGotostmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(418);
    match(BasicParser::GOTO);
    setState(419);
    linenumber();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GosubstmtContext ------------------------------------------------------------------

BasicParser::GosubstmtContext::GosubstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::GosubstmtContext::GOSUB() {
  return getToken(BasicParser::GOSUB, 0);
}

BasicParser::ExpressionContext* BasicParser::GosubstmtContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}


size_t BasicParser::GosubstmtContext::getRuleIndex() const {
  return BasicParser::RuleGosubstmt;
}


std::any BasicParser::GosubstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitGosubstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::GosubstmtContext* BasicParser::gosubstmt() {
  GosubstmtContext *_localctx = _tracker.createInstance<GosubstmtContext>(_ctx, getState());
  enterRule(_localctx, 44, BasicParser::RuleGosubstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(421);
    match(BasicParser::GOSUB);
    setState(422);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PokestmtContext ------------------------------------------------------------------

BasicParser::PokestmtContext::PokestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::PokestmtContext::POKE() {
  return getToken(BasicParser::POKE, 0);
}

std::vector<BasicParser::ExpressionContext *> BasicParser::PokestmtContext::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::PokestmtContext::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

tree::TerminalNode* BasicParser::PokestmtContext::COMMA() {
  return getToken(BasicParser::COMMA, 0);
}


size_t BasicParser::PokestmtContext::getRuleIndex() const {
  return BasicParser::RulePokestmt;
}


std::any BasicParser::PokestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitPokestmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::PokestmtContext* BasicParser::pokestmt() {
  PokestmtContext *_localctx = _tracker.createInstance<PokestmtContext>(_ctx, getState());
  enterRule(_localctx, 46, BasicParser::RulePokestmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(424);
    match(BasicParser::POKE);
    setState(425);
    expression();
    setState(426);
    match(BasicParser::COMMA);
    setState(427);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallstmtContext ------------------------------------------------------------------

BasicParser::CallstmtContext::CallstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::CallstmtContext::CALL() {
  return getToken(BasicParser::CALL, 0);
}

BasicParser::ExprlistContext* BasicParser::CallstmtContext::exprlist() {
  return getRuleContext<BasicParser::ExprlistContext>(0);
}


size_t BasicParser::CallstmtContext::getRuleIndex() const {
  return BasicParser::RuleCallstmt;
}


std::any BasicParser::CallstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitCallstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::CallstmtContext* BasicParser::callstmt() {
  CallstmtContext *_localctx = _tracker.createInstance<CallstmtContext>(_ctx, getState());
  enterRule(_localctx, 48, BasicParser::RuleCallstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(429);
    match(BasicParser::CALL);
    setState(430);
    exprlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HplotstmtContext ------------------------------------------------------------------

BasicParser::HplotstmtContext::HplotstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::HplotstmtContext::HPLOT() {
  return getToken(BasicParser::HPLOT, 0);
}

std::vector<BasicParser::ExpressionContext *> BasicParser::HplotstmtContext::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::HplotstmtContext::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> BasicParser::HplotstmtContext::COMMA() {
  return getTokens(BasicParser::COMMA);
}

tree::TerminalNode* BasicParser::HplotstmtContext::COMMA(size_t i) {
  return getToken(BasicParser::COMMA, i);
}

std::vector<tree::TerminalNode *> BasicParser::HplotstmtContext::TO() {
  return getTokens(BasicParser::TO);
}

tree::TerminalNode* BasicParser::HplotstmtContext::TO(size_t i) {
  return getToken(BasicParser::TO, i);
}


size_t BasicParser::HplotstmtContext::getRuleIndex() const {
  return BasicParser::RuleHplotstmt;
}


std::any BasicParser::HplotstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitHplotstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::HplotstmtContext* BasicParser::hplotstmt() {
  HplotstmtContext *_localctx = _tracker.createInstance<HplotstmtContext>(_ctx, getState());
  enterRule(_localctx, 50, BasicParser::RuleHplotstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(432);
    match(BasicParser::HPLOT);
    setState(437);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
    case 1: {
      setState(433);
      expression();
      setState(434);
      match(BasicParser::COMMA);
      setState(435);
      expression();
      break;
    }

    default:
      break;
    }
    setState(446);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == BasicParser::TO) {
      setState(439);
      match(BasicParser::TO);
      setState(440);
      expression();
      setState(441);
      match(BasicParser::COMMA);
      setState(442);
      expression();
      setState(448);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VplotstmtContext ------------------------------------------------------------------

BasicParser::VplotstmtContext::VplotstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::VplotstmtContext::VPLOT() {
  return getToken(BasicParser::VPLOT, 0);
}

std::vector<BasicParser::ExpressionContext *> BasicParser::VplotstmtContext::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::VplotstmtContext::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> BasicParser::VplotstmtContext::COMMA() {
  return getTokens(BasicParser::COMMA);
}

tree::TerminalNode* BasicParser::VplotstmtContext::COMMA(size_t i) {
  return getToken(BasicParser::COMMA, i);
}

std::vector<tree::TerminalNode *> BasicParser::VplotstmtContext::TO() {
  return getTokens(BasicParser::TO);
}

tree::TerminalNode* BasicParser::VplotstmtContext::TO(size_t i) {
  return getToken(BasicParser::TO, i);
}


size_t BasicParser::VplotstmtContext::getRuleIndex() const {
  return BasicParser::RuleVplotstmt;
}


std::any BasicParser::VplotstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitVplotstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::VplotstmtContext* BasicParser::vplotstmt() {
  VplotstmtContext *_localctx = _tracker.createInstance<VplotstmtContext>(_ctx, getState());
  enterRule(_localctx, 52, BasicParser::RuleVplotstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(449);
    match(BasicParser::VPLOT);
    setState(454);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      setState(450);
      expression();
      setState(451);
      match(BasicParser::COMMA);
      setState(452);
      expression();
      break;
    }

    default:
      break;
    }
    setState(463);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == BasicParser::TO) {
      setState(456);
      match(BasicParser::TO);
      setState(457);
      expression();
      setState(458);
      match(BasicParser::COMMA);
      setState(459);
      expression();
      setState(465);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PlotstmtContext ------------------------------------------------------------------

BasicParser::PlotstmtContext::PlotstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::PlotstmtContext::PLOT() {
  return getToken(BasicParser::PLOT, 0);
}

std::vector<BasicParser::ExpressionContext *> BasicParser::PlotstmtContext::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::PlotstmtContext::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

tree::TerminalNode* BasicParser::PlotstmtContext::COMMA() {
  return getToken(BasicParser::COMMA, 0);
}


size_t BasicParser::PlotstmtContext::getRuleIndex() const {
  return BasicParser::RulePlotstmt;
}


std::any BasicParser::PlotstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitPlotstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::PlotstmtContext* BasicParser::plotstmt() {
  PlotstmtContext *_localctx = _tracker.createInstance<PlotstmtContext>(_ctx, getState());
  enterRule(_localctx, 54, BasicParser::RulePlotstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(466);
    match(BasicParser::PLOT);
    setState(467);
    expression();
    setState(468);
    match(BasicParser::COMMA);
    setState(469);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OngotostmtContext ------------------------------------------------------------------

BasicParser::OngotostmtContext::OngotostmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::OngotostmtContext::ON() {
  return getToken(BasicParser::ON, 0);
}

BasicParser::ExpressionContext* BasicParser::OngotostmtContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::OngotostmtContext::GOTO() {
  return getToken(BasicParser::GOTO, 0);
}

std::vector<BasicParser::LinenumberContext *> BasicParser::OngotostmtContext::linenumber() {
  return getRuleContexts<BasicParser::LinenumberContext>();
}

BasicParser::LinenumberContext* BasicParser::OngotostmtContext::linenumber(size_t i) {
  return getRuleContext<BasicParser::LinenumberContext>(i);
}

std::vector<tree::TerminalNode *> BasicParser::OngotostmtContext::COMMA() {
  return getTokens(BasicParser::COMMA);
}

tree::TerminalNode* BasicParser::OngotostmtContext::COMMA(size_t i) {
  return getToken(BasicParser::COMMA, i);
}


size_t BasicParser::OngotostmtContext::getRuleIndex() const {
  return BasicParser::RuleOngotostmt;
}


std::any BasicParser::OngotostmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitOngotostmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::OngotostmtContext* BasicParser::ongotostmt() {
  OngotostmtContext *_localctx = _tracker.createInstance<OngotostmtContext>(_ctx, getState());
  enterRule(_localctx, 56, BasicParser::RuleOngotostmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(471);
    match(BasicParser::ON);
    setState(472);
    expression();
    setState(473);
    match(BasicParser::GOTO);
    setState(474);
    linenumber();
    setState(479);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == BasicParser::COMMA) {
      setState(475);
      match(BasicParser::COMMA);
      setState(476);
      linenumber();
      setState(481);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OngosubstmtContext ------------------------------------------------------------------

BasicParser::OngosubstmtContext::OngosubstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::OngosubstmtContext::ON() {
  return getToken(BasicParser::ON, 0);
}

BasicParser::ExpressionContext* BasicParser::OngosubstmtContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::OngosubstmtContext::GOSUB() {
  return getToken(BasicParser::GOSUB, 0);
}

std::vector<BasicParser::LinenumberContext *> BasicParser::OngosubstmtContext::linenumber() {
  return getRuleContexts<BasicParser::LinenumberContext>();
}

BasicParser::LinenumberContext* BasicParser::OngosubstmtContext::linenumber(size_t i) {
  return getRuleContext<BasicParser::LinenumberContext>(i);
}

std::vector<tree::TerminalNode *> BasicParser::OngosubstmtContext::COMMA() {
  return getTokens(BasicParser::COMMA);
}

tree::TerminalNode* BasicParser::OngosubstmtContext::COMMA(size_t i) {
  return getToken(BasicParser::COMMA, i);
}


size_t BasicParser::OngosubstmtContext::getRuleIndex() const {
  return BasicParser::RuleOngosubstmt;
}


std::any BasicParser::OngosubstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitOngosubstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::OngosubstmtContext* BasicParser::ongosubstmt() {
  OngosubstmtContext *_localctx = _tracker.createInstance<OngosubstmtContext>(_ctx, getState());
  enterRule(_localctx, 58, BasicParser::RuleOngosubstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(482);
    match(BasicParser::ON);
    setState(483);
    expression();
    setState(484);
    match(BasicParser::GOSUB);
    setState(485);
    linenumber();
    setState(490);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == BasicParser::COMMA) {
      setState(486);
      match(BasicParser::COMMA);
      setState(487);
      linenumber();
      setState(492);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VtabstmntContext ------------------------------------------------------------------

BasicParser::VtabstmntContext::VtabstmntContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::VtabstmntContext::VTAB() {
  return getToken(BasicParser::VTAB, 0);
}

BasicParser::ExpressionContext* BasicParser::VtabstmntContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}


size_t BasicParser::VtabstmntContext::getRuleIndex() const {
  return BasicParser::RuleVtabstmnt;
}


std::any BasicParser::VtabstmntContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitVtabstmnt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::VtabstmntContext* BasicParser::vtabstmnt() {
  VtabstmntContext *_localctx = _tracker.createInstance<VtabstmntContext>(_ctx, getState());
  enterRule(_localctx, 60, BasicParser::RuleVtabstmnt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(493);
    match(BasicParser::VTAB);
    setState(494);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HtabstmntContext ------------------------------------------------------------------

BasicParser::HtabstmntContext::HtabstmntContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::HtabstmntContext::HTAB() {
  return getToken(BasicParser::HTAB, 0);
}

BasicParser::ExpressionContext* BasicParser::HtabstmntContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}


size_t BasicParser::HtabstmntContext::getRuleIndex() const {
  return BasicParser::RuleHtabstmnt;
}


std::any BasicParser::HtabstmntContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitHtabstmnt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::HtabstmntContext* BasicParser::htabstmnt() {
  HtabstmntContext *_localctx = _tracker.createInstance<HtabstmntContext>(_ctx, getState());
  enterRule(_localctx, 62, BasicParser::RuleHtabstmnt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(496);
    match(BasicParser::HTAB);
    setState(497);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HimemstmtContext ------------------------------------------------------------------

BasicParser::HimemstmtContext::HimemstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::HimemstmtContext::HIMEM() {
  return getToken(BasicParser::HIMEM, 0);
}

tree::TerminalNode* BasicParser::HimemstmtContext::COLON() {
  return getToken(BasicParser::COLON, 0);
}

BasicParser::ExpressionContext* BasicParser::HimemstmtContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}


size_t BasicParser::HimemstmtContext::getRuleIndex() const {
  return BasicParser::RuleHimemstmt;
}


std::any BasicParser::HimemstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitHimemstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::HimemstmtContext* BasicParser::himemstmt() {
  HimemstmtContext *_localctx = _tracker.createInstance<HimemstmtContext>(_ctx, getState());
  enterRule(_localctx, 64, BasicParser::RuleHimemstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(499);
    match(BasicParser::HIMEM);
    setState(500);
    match(BasicParser::COLON);
    setState(501);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LomemstmtContext ------------------------------------------------------------------

BasicParser::LomemstmtContext::LomemstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::LomemstmtContext::LOMEM() {
  return getToken(BasicParser::LOMEM, 0);
}

tree::TerminalNode* BasicParser::LomemstmtContext::COLON() {
  return getToken(BasicParser::COLON, 0);
}

BasicParser::ExpressionContext* BasicParser::LomemstmtContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}


size_t BasicParser::LomemstmtContext::getRuleIndex() const {
  return BasicParser::RuleLomemstmt;
}


std::any BasicParser::LomemstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitLomemstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::LomemstmtContext* BasicParser::lomemstmt() {
  LomemstmtContext *_localctx = _tracker.createInstance<LomemstmtContext>(_ctx, getState());
  enterRule(_localctx, 66, BasicParser::RuleLomemstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(503);
    match(BasicParser::LOMEM);
    setState(504);
    match(BasicParser::COLON);
    setState(505);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DatastmtContext ------------------------------------------------------------------

BasicParser::DatastmtContext::DatastmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::DatastmtContext::DATA() {
  return getToken(BasicParser::DATA, 0);
}

std::vector<BasicParser::DatumContext *> BasicParser::DatastmtContext::datum() {
  return getRuleContexts<BasicParser::DatumContext>();
}

BasicParser::DatumContext* BasicParser::DatastmtContext::datum(size_t i) {
  return getRuleContext<BasicParser::DatumContext>(i);
}

std::vector<tree::TerminalNode *> BasicParser::DatastmtContext::COMMA() {
  return getTokens(BasicParser::COMMA);
}

tree::TerminalNode* BasicParser::DatastmtContext::COMMA(size_t i) {
  return getToken(BasicParser::COMMA, i);
}


size_t BasicParser::DatastmtContext::getRuleIndex() const {
  return BasicParser::RuleDatastmt;
}


std::any BasicParser::DatastmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitDatastmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::DatastmtContext* BasicParser::datastmt() {
  DatastmtContext *_localctx = _tracker.createInstance<DatastmtContext>(_ctx, getState());
  enterRule(_localctx, 68, BasicParser::RuleDatastmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(507);
    match(BasicParser::DATA);
    setState(508);
    datum();
    setState(515);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == BasicParser::COMMA) {
      setState(509);
      match(BasicParser::COMMA);
      setState(511);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
      case 1: {
        setState(510);
        datum();
        break;
      }

      default:
        break;
      }
      setState(517);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DatumContext ------------------------------------------------------------------

BasicParser::DatumContext::DatumContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

BasicParser::NumberContext* BasicParser::DatumContext::number() {
  return getRuleContext<BasicParser::NumberContext>(0);
}

tree::TerminalNode* BasicParser::DatumContext::STRINGLITERAL() {
  return getToken(BasicParser::STRINGLITERAL, 0);
}


size_t BasicParser::DatumContext::getRuleIndex() const {
  return BasicParser::RuleDatum;
}


std::any BasicParser::DatumContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitDatum(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::DatumContext* BasicParser::datum() {
  DatumContext *_localctx = _tracker.createInstance<DatumContext>(_ctx, getState());
  enterRule(_localctx, 70, BasicParser::RuleDatum);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(520);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case BasicParser::PLUS:
      case BasicParser::MINUS:
      case BasicParser::NUMBER:
      case BasicParser::FLOAT: {
        enterOuterAlt(_localctx, 1);
        setState(518);
        number();
        break;
      }

      case BasicParser::STRINGLITERAL: {
        enterOuterAlt(_localctx, 2);
        setState(519);
        match(BasicParser::STRINGLITERAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WaitstmtContext ------------------------------------------------------------------

BasicParser::WaitstmtContext::WaitstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::WaitstmtContext::WAIT() {
  return getToken(BasicParser::WAIT, 0);
}

std::vector<BasicParser::ExpressionContext *> BasicParser::WaitstmtContext::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::WaitstmtContext::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> BasicParser::WaitstmtContext::COMMA() {
  return getTokens(BasicParser::COMMA);
}

tree::TerminalNode* BasicParser::WaitstmtContext::COMMA(size_t i) {
  return getToken(BasicParser::COMMA, i);
}


size_t BasicParser::WaitstmtContext::getRuleIndex() const {
  return BasicParser::RuleWaitstmt;
}


std::any BasicParser::WaitstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitWaitstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::WaitstmtContext* BasicParser::waitstmt() {
  WaitstmtContext *_localctx = _tracker.createInstance<WaitstmtContext>(_ctx, getState());
  enterRule(_localctx, 72, BasicParser::RuleWaitstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(522);
    match(BasicParser::WAIT);
    setState(523);
    expression();
    setState(524);
    match(BasicParser::COMMA);
    setState(525);
    expression();
    setState(528);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == BasicParser::COMMA) {
      setState(526);
      match(BasicParser::COMMA);
      setState(527);
      expression();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XdrawstmtContext ------------------------------------------------------------------

BasicParser::XdrawstmtContext::XdrawstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::XdrawstmtContext::XDRAW() {
  return getToken(BasicParser::XDRAW, 0);
}

std::vector<BasicParser::ExpressionContext *> BasicParser::XdrawstmtContext::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::XdrawstmtContext::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

tree::TerminalNode* BasicParser::XdrawstmtContext::AT() {
  return getToken(BasicParser::AT, 0);
}

tree::TerminalNode* BasicParser::XdrawstmtContext::COMMA() {
  return getToken(BasicParser::COMMA, 0);
}


size_t BasicParser::XdrawstmtContext::getRuleIndex() const {
  return BasicParser::RuleXdrawstmt;
}


std::any BasicParser::XdrawstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitXdrawstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::XdrawstmtContext* BasicParser::xdrawstmt() {
  XdrawstmtContext *_localctx = _tracker.createInstance<XdrawstmtContext>(_ctx, getState());
  enterRule(_localctx, 74, BasicParser::RuleXdrawstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(530);
    match(BasicParser::XDRAW);
    setState(531);
    expression();
    setState(537);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == BasicParser::AT) {
      setState(532);
      match(BasicParser::AT);
      setState(533);
      expression();
      setState(534);
      match(BasicParser::COMMA);
      setState(535);
      expression();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DrawstmtContext ------------------------------------------------------------------

BasicParser::DrawstmtContext::DrawstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::DrawstmtContext::DRAW() {
  return getToken(BasicParser::DRAW, 0);
}

std::vector<BasicParser::ExpressionContext *> BasicParser::DrawstmtContext::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::DrawstmtContext::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

tree::TerminalNode* BasicParser::DrawstmtContext::AT() {
  return getToken(BasicParser::AT, 0);
}

tree::TerminalNode* BasicParser::DrawstmtContext::COMMA() {
  return getToken(BasicParser::COMMA, 0);
}


size_t BasicParser::DrawstmtContext::getRuleIndex() const {
  return BasicParser::RuleDrawstmt;
}


std::any BasicParser::DrawstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitDrawstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::DrawstmtContext* BasicParser::drawstmt() {
  DrawstmtContext *_localctx = _tracker.createInstance<DrawstmtContext>(_ctx, getState());
  enterRule(_localctx, 76, BasicParser::RuleDrawstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(539);
    match(BasicParser::DRAW);
    setState(540);
    expression();
    setState(546);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == BasicParser::AT) {
      setState(541);
      match(BasicParser::AT);
      setState(542);
      expression();
      setState(543);
      match(BasicParser::COMMA);
      setState(544);
      expression();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefstmtContext ------------------------------------------------------------------

BasicParser::DefstmtContext::DefstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::DefstmtContext::DEF() {
  return getToken(BasicParser::DEF, 0);
}

std::vector<BasicParser::Var_Context *> BasicParser::DefstmtContext::var_() {
  return getRuleContexts<BasicParser::Var_Context>();
}

BasicParser::Var_Context* BasicParser::DefstmtContext::var_(size_t i) {
  return getRuleContext<BasicParser::Var_Context>(i);
}

tree::TerminalNode* BasicParser::DefstmtContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

tree::TerminalNode* BasicParser::DefstmtContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}

tree::TerminalNode* BasicParser::DefstmtContext::EQ() {
  return getToken(BasicParser::EQ, 0);
}

BasicParser::ExpressionContext* BasicParser::DefstmtContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::DefstmtContext::FN() {
  return getToken(BasicParser::FN, 0);
}


size_t BasicParser::DefstmtContext::getRuleIndex() const {
  return BasicParser::RuleDefstmt;
}


std::any BasicParser::DefstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitDefstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::DefstmtContext* BasicParser::defstmt() {
  DefstmtContext *_localctx = _tracker.createInstance<DefstmtContext>(_ctx, getState());
  enterRule(_localctx, 78, BasicParser::RuleDefstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(548);
    match(BasicParser::DEF);
    setState(550);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == BasicParser::FN) {
      setState(549);
      match(BasicParser::FN);
    }
    setState(552);
    var_();
    setState(553);
    match(BasicParser::LPAREN);
    setState(554);
    var_();
    setState(555);
    match(BasicParser::RPAREN);
    setState(556);
    match(BasicParser::EQ);
    setState(557);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TabstmtContext ------------------------------------------------------------------

BasicParser::TabstmtContext::TabstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::TabstmtContext::TAB() {
  return getToken(BasicParser::TAB, 0);
}

tree::TerminalNode* BasicParser::TabstmtContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::TabstmtContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::TabstmtContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::TabstmtContext::getRuleIndex() const {
  return BasicParser::RuleTabstmt;
}


std::any BasicParser::TabstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitTabstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::TabstmtContext* BasicParser::tabstmt() {
  TabstmtContext *_localctx = _tracker.createInstance<TabstmtContext>(_ctx, getState());
  enterRule(_localctx, 80, BasicParser::RuleTabstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(559);
    match(BasicParser::TAB);
    setState(560);
    match(BasicParser::LPAREN);
    setState(561);
    expression();
    setState(562);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpeedstmtContext ------------------------------------------------------------------

BasicParser::SpeedstmtContext::SpeedstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::SpeedstmtContext::SPEED() {
  return getToken(BasicParser::SPEED, 0);
}

tree::TerminalNode* BasicParser::SpeedstmtContext::EQ() {
  return getToken(BasicParser::EQ, 0);
}

BasicParser::ExpressionContext* BasicParser::SpeedstmtContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}


size_t BasicParser::SpeedstmtContext::getRuleIndex() const {
  return BasicParser::RuleSpeedstmt;
}


std::any BasicParser::SpeedstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitSpeedstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::SpeedstmtContext* BasicParser::speedstmt() {
  SpeedstmtContext *_localctx = _tracker.createInstance<SpeedstmtContext>(_ctx, getState());
  enterRule(_localctx, 82, BasicParser::RuleSpeedstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(564);
    match(BasicParser::SPEED);
    setState(565);
    match(BasicParser::EQ);
    setState(566);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RotstmtContext ------------------------------------------------------------------

BasicParser::RotstmtContext::RotstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::RotstmtContext::ROT() {
  return getToken(BasicParser::ROT, 0);
}

tree::TerminalNode* BasicParser::RotstmtContext::EQ() {
  return getToken(BasicParser::EQ, 0);
}

BasicParser::ExpressionContext* BasicParser::RotstmtContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}


size_t BasicParser::RotstmtContext::getRuleIndex() const {
  return BasicParser::RuleRotstmt;
}


std::any BasicParser::RotstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitRotstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::RotstmtContext* BasicParser::rotstmt() {
  RotstmtContext *_localctx = _tracker.createInstance<RotstmtContext>(_ctx, getState());
  enterRule(_localctx, 84, BasicParser::RuleRotstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(568);
    match(BasicParser::ROT);
    setState(569);
    match(BasicParser::EQ);
    setState(570);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScalestmtContext ------------------------------------------------------------------

BasicParser::ScalestmtContext::ScalestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::ScalestmtContext::SCALE() {
  return getToken(BasicParser::SCALE, 0);
}

tree::TerminalNode* BasicParser::ScalestmtContext::EQ() {
  return getToken(BasicParser::EQ, 0);
}

BasicParser::ExpressionContext* BasicParser::ScalestmtContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}


size_t BasicParser::ScalestmtContext::getRuleIndex() const {
  return BasicParser::RuleScalestmt;
}


std::any BasicParser::ScalestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitScalestmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::ScalestmtContext* BasicParser::scalestmt() {
  ScalestmtContext *_localctx = _tracker.createInstance<ScalestmtContext>(_ctx, getState());
  enterRule(_localctx, 86, BasicParser::RuleScalestmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(572);
    match(BasicParser::SCALE);
    setState(573);
    match(BasicParser::EQ);
    setState(574);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColorstmtContext ------------------------------------------------------------------

BasicParser::ColorstmtContext::ColorstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::ColorstmtContext::COLOR() {
  return getToken(BasicParser::COLOR, 0);
}

tree::TerminalNode* BasicParser::ColorstmtContext::EQ() {
  return getToken(BasicParser::EQ, 0);
}

BasicParser::ExpressionContext* BasicParser::ColorstmtContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}


size_t BasicParser::ColorstmtContext::getRuleIndex() const {
  return BasicParser::RuleColorstmt;
}


std::any BasicParser::ColorstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitColorstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::ColorstmtContext* BasicParser::colorstmt() {
  ColorstmtContext *_localctx = _tracker.createInstance<ColorstmtContext>(_ctx, getState());
  enterRule(_localctx, 88, BasicParser::RuleColorstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(576);
    match(BasicParser::COLOR);
    setState(577);
    match(BasicParser::EQ);
    setState(578);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HcolorstmtContext ------------------------------------------------------------------

BasicParser::HcolorstmtContext::HcolorstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::HcolorstmtContext::HCOLOR() {
  return getToken(BasicParser::HCOLOR, 0);
}

tree::TerminalNode* BasicParser::HcolorstmtContext::EQ() {
  return getToken(BasicParser::EQ, 0);
}

BasicParser::ExpressionContext* BasicParser::HcolorstmtContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}


size_t BasicParser::HcolorstmtContext::getRuleIndex() const {
  return BasicParser::RuleHcolorstmt;
}


std::any BasicParser::HcolorstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitHcolorstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::HcolorstmtContext* BasicParser::hcolorstmt() {
  HcolorstmtContext *_localctx = _tracker.createInstance<HcolorstmtContext>(_ctx, getState());
  enterRule(_localctx, 90, BasicParser::RuleHcolorstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(580);
    match(BasicParser::HCOLOR);
    setState(581);
    match(BasicParser::EQ);
    setState(582);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HlinstmtContext ------------------------------------------------------------------

BasicParser::HlinstmtContext::HlinstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::HlinstmtContext::HLIN() {
  return getToken(BasicParser::HLIN, 0);
}

std::vector<BasicParser::ExpressionContext *> BasicParser::HlinstmtContext::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::HlinstmtContext::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

tree::TerminalNode* BasicParser::HlinstmtContext::COMMA() {
  return getToken(BasicParser::COMMA, 0);
}

tree::TerminalNode* BasicParser::HlinstmtContext::AT() {
  return getToken(BasicParser::AT, 0);
}


size_t BasicParser::HlinstmtContext::getRuleIndex() const {
  return BasicParser::RuleHlinstmt;
}


std::any BasicParser::HlinstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitHlinstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::HlinstmtContext* BasicParser::hlinstmt() {
  HlinstmtContext *_localctx = _tracker.createInstance<HlinstmtContext>(_ctx, getState());
  enterRule(_localctx, 92, BasicParser::RuleHlinstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(584);
    match(BasicParser::HLIN);
    setState(585);
    expression();
    setState(586);
    match(BasicParser::COMMA);
    setState(587);
    expression();
    setState(588);
    match(BasicParser::AT);
    setState(589);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VlinstmtContext ------------------------------------------------------------------

BasicParser::VlinstmtContext::VlinstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::VlinstmtContext::VLIN() {
  return getToken(BasicParser::VLIN, 0);
}

std::vector<BasicParser::ExpressionContext *> BasicParser::VlinstmtContext::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::VlinstmtContext::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

tree::TerminalNode* BasicParser::VlinstmtContext::COMMA() {
  return getToken(BasicParser::COMMA, 0);
}

tree::TerminalNode* BasicParser::VlinstmtContext::AT() {
  return getToken(BasicParser::AT, 0);
}


size_t BasicParser::VlinstmtContext::getRuleIndex() const {
  return BasicParser::RuleVlinstmt;
}


std::any BasicParser::VlinstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitVlinstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::VlinstmtContext* BasicParser::vlinstmt() {
  VlinstmtContext *_localctx = _tracker.createInstance<VlinstmtContext>(_ctx, getState());
  enterRule(_localctx, 94, BasicParser::RuleVlinstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(591);
    match(BasicParser::VLIN);
    setState(592);
    expression();
    setState(593);
    match(BasicParser::COMMA);
    setState(594);
    expression();
    setState(595);
    match(BasicParser::AT);
    setState(596);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnerrstmtContext ------------------------------------------------------------------

BasicParser::OnerrstmtContext::OnerrstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::OnerrstmtContext::ONERR() {
  return getToken(BasicParser::ONERR, 0);
}

tree::TerminalNode* BasicParser::OnerrstmtContext::GOTO() {
  return getToken(BasicParser::GOTO, 0);
}

BasicParser::LinenumberContext* BasicParser::OnerrstmtContext::linenumber() {
  return getRuleContext<BasicParser::LinenumberContext>(0);
}


size_t BasicParser::OnerrstmtContext::getRuleIndex() const {
  return BasicParser::RuleOnerrstmt;
}


std::any BasicParser::OnerrstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitOnerrstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::OnerrstmtContext* BasicParser::onerrstmt() {
  OnerrstmtContext *_localctx = _tracker.createInstance<OnerrstmtContext>(_ctx, getState());
  enterRule(_localctx, 96, BasicParser::RuleOnerrstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(598);
    match(BasicParser::ONERR);
    setState(599);
    match(BasicParser::GOTO);
    setState(600);
    linenumber();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrstmtContext ------------------------------------------------------------------

BasicParser::PrstmtContext::PrstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::PrstmtContext::PRNUMBER() {
  return getToken(BasicParser::PRNUMBER, 0);
}

tree::TerminalNode* BasicParser::PrstmtContext::NUMBER() {
  return getToken(BasicParser::NUMBER, 0);
}


size_t BasicParser::PrstmtContext::getRuleIndex() const {
  return BasicParser::RulePrstmt;
}


std::any BasicParser::PrstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitPrstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::PrstmtContext* BasicParser::prstmt() {
  PrstmtContext *_localctx = _tracker.createInstance<PrstmtContext>(_ctx, getState());
  enterRule(_localctx, 98, BasicParser::RulePrstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(602);
    match(BasicParser::PRNUMBER);
    setState(603);
    match(BasicParser::NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InstmtContext ------------------------------------------------------------------

BasicParser::InstmtContext::InstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::InstmtContext::INNUMBER() {
  return getToken(BasicParser::INNUMBER, 0);
}

tree::TerminalNode* BasicParser::InstmtContext::NUMBER() {
  return getToken(BasicParser::NUMBER, 0);
}


size_t BasicParser::InstmtContext::getRuleIndex() const {
  return BasicParser::RuleInstmt;
}


std::any BasicParser::InstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitInstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::InstmtContext* BasicParser::instmt() {
  InstmtContext *_localctx = _tracker.createInstance<InstmtContext>(_ctx, getState());
  enterRule(_localctx, 100, BasicParser::RuleInstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(605);
    match(BasicParser::INNUMBER);
    setState(606);
    match(BasicParser::NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StorestmtContext ------------------------------------------------------------------

BasicParser::StorestmtContext::StorestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::StorestmtContext::STORE() {
  return getToken(BasicParser::STORE, 0);
}

BasicParser::VardeclContext* BasicParser::StorestmtContext::vardecl() {
  return getRuleContext<BasicParser::VardeclContext>(0);
}


size_t BasicParser::StorestmtContext::getRuleIndex() const {
  return BasicParser::RuleStorestmt;
}


std::any BasicParser::StorestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitStorestmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::StorestmtContext* BasicParser::storestmt() {
  StorestmtContext *_localctx = _tracker.createInstance<StorestmtContext>(_ctx, getState());
  enterRule(_localctx, 102, BasicParser::RuleStorestmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(608);
    match(BasicParser::STORE);
    setState(609);
    vardecl();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RecallstmtContext ------------------------------------------------------------------

BasicParser::RecallstmtContext::RecallstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::RecallstmtContext::RECALL() {
  return getToken(BasicParser::RECALL, 0);
}

BasicParser::VardeclContext* BasicParser::RecallstmtContext::vardecl() {
  return getRuleContext<BasicParser::VardeclContext>(0);
}


size_t BasicParser::RecallstmtContext::getRuleIndex() const {
  return BasicParser::RuleRecallstmt;
}


std::any BasicParser::RecallstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitRecallstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::RecallstmtContext* BasicParser::recallstmt() {
  RecallstmtContext *_localctx = _tracker.createInstance<RecallstmtContext>(_ctx, getState());
  enterRule(_localctx, 104, BasicParser::RuleRecallstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(611);
    match(BasicParser::RECALL);
    setState(612);
    vardecl();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ListstmtContext ------------------------------------------------------------------

BasicParser::ListstmtContext::ListstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::ListstmtContext::LIST() {
  return getToken(BasicParser::LIST, 0);
}

BasicParser::ExpressionContext* BasicParser::ListstmtContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}


size_t BasicParser::ListstmtContext::getRuleIndex() const {
  return BasicParser::RuleListstmt;
}


std::any BasicParser::ListstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitListstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::ListstmtContext* BasicParser::liststmt() {
  ListstmtContext *_localctx = _tracker.createInstance<ListstmtContext>(_ctx, getState());
  enterRule(_localctx, 106, BasicParser::RuleListstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(614);
    match(BasicParser::LIST);
    setState(616);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      setState(615);
      expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PopstmtContext ------------------------------------------------------------------

BasicParser::PopstmtContext::PopstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::PopstmtContext::POP() {
  return getToken(BasicParser::POP, 0);
}

std::vector<BasicParser::ExpressionContext *> BasicParser::PopstmtContext::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::PopstmtContext::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

tree::TerminalNode* BasicParser::PopstmtContext::COMMA() {
  return getToken(BasicParser::COMMA, 0);
}


size_t BasicParser::PopstmtContext::getRuleIndex() const {
  return BasicParser::RulePopstmt;
}


std::any BasicParser::PopstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitPopstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::PopstmtContext* BasicParser::popstmt() {
  PopstmtContext *_localctx = _tracker.createInstance<PopstmtContext>(_ctx, getState());
  enterRule(_localctx, 108, BasicParser::RulePopstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(618);
    match(BasicParser::POP);
    setState(623);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
    case 1: {
      setState(619);
      expression();
      setState(620);
      match(BasicParser::COMMA);
      setState(621);
      expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AmptstmtContext ------------------------------------------------------------------

BasicParser::AmptstmtContext::AmptstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::AmptstmtContext::AMPERSAND() {
  return getToken(BasicParser::AMPERSAND, 0);
}

BasicParser::ExpressionContext* BasicParser::AmptstmtContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}


size_t BasicParser::AmptstmtContext::getRuleIndex() const {
  return BasicParser::RuleAmptstmt;
}


std::any BasicParser::AmptstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitAmptstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::AmptstmtContext* BasicParser::amptstmt() {
  AmptstmtContext *_localctx = _tracker.createInstance<AmptstmtContext>(_ctx, getState());
  enterRule(_localctx, 110, BasicParser::RuleAmptstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(625);
    match(BasicParser::AMPERSAND);
    setState(626);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IncludestmtContext ------------------------------------------------------------------

BasicParser::IncludestmtContext::IncludestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::IncludestmtContext::INCLUDE() {
  return getToken(BasicParser::INCLUDE, 0);
}

BasicParser::ExpressionContext* BasicParser::IncludestmtContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}


size_t BasicParser::IncludestmtContext::getRuleIndex() const {
  return BasicParser::RuleIncludestmt;
}


std::any BasicParser::IncludestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitIncludestmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::IncludestmtContext* BasicParser::includestmt() {
  IncludestmtContext *_localctx = _tracker.createInstance<IncludestmtContext>(_ctx, getState());
  enterRule(_localctx, 112, BasicParser::RuleIncludestmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(628);
    match(BasicParser::INCLUDE);
    setState(629);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndstmtContext ------------------------------------------------------------------

BasicParser::EndstmtContext::EndstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::EndstmtContext::END() {
  return getToken(BasicParser::END, 0);
}


size_t BasicParser::EndstmtContext::getRuleIndex() const {
  return BasicParser::RuleEndstmt;
}


std::any BasicParser::EndstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitEndstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::EndstmtContext* BasicParser::endstmt() {
  EndstmtContext *_localctx = _tracker.createInstance<EndstmtContext>(_ctx, getState());
  enterRule(_localctx, 114, BasicParser::RuleEndstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(631);
    match(BasicParser::END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnstmtContext ------------------------------------------------------------------

BasicParser::ReturnstmtContext::ReturnstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::ReturnstmtContext::RETURN() {
  return getToken(BasicParser::RETURN, 0);
}


size_t BasicParser::ReturnstmtContext::getRuleIndex() const {
  return BasicParser::RuleReturnstmt;
}


std::any BasicParser::ReturnstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitReturnstmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::ReturnstmtContext* BasicParser::returnstmt() {
  ReturnstmtContext *_localctx = _tracker.createInstance<ReturnstmtContext>(_ctx, getState());
  enterRule(_localctx, 116, BasicParser::RuleReturnstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(633);
    match(BasicParser::RETURN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RestorestmtContext ------------------------------------------------------------------

BasicParser::RestorestmtContext::RestorestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::RestorestmtContext::RESTORE() {
  return getToken(BasicParser::RESTORE, 0);
}


size_t BasicParser::RestorestmtContext::getRuleIndex() const {
  return BasicParser::RuleRestorestmt;
}


std::any BasicParser::RestorestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitRestorestmt(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::RestorestmtContext* BasicParser::restorestmt() {
  RestorestmtContext *_localctx = _tracker.createInstance<RestorestmtContext>(_ctx, getState());
  enterRule(_localctx, 118, BasicParser::RuleRestorestmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(635);
    match(BasicParser::RESTORE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberContext ------------------------------------------------------------------

BasicParser::NumberContext::NumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::NumberContext::NUMBER() {
  return getToken(BasicParser::NUMBER, 0);
}

tree::TerminalNode* BasicParser::NumberContext::FLOAT() {
  return getToken(BasicParser::FLOAT, 0);
}

tree::TerminalNode* BasicParser::NumberContext::PLUS() {
  return getToken(BasicParser::PLUS, 0);
}

tree::TerminalNode* BasicParser::NumberContext::MINUS() {
  return getToken(BasicParser::MINUS, 0);
}


size_t BasicParser::NumberContext::getRuleIndex() const {
  return BasicParser::RuleNumber;
}


std::any BasicParser::NumberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitNumber(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::NumberContext* BasicParser::number() {
  NumberContext *_localctx = _tracker.createInstance<NumberContext>(_ctx, getState());
  enterRule(_localctx, 120, BasicParser::RuleNumber);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(638);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == BasicParser::PLUS

    || _la == BasicParser::MINUS) {
      setState(637);
      _la = _input->LA(1);
      if (!(_la == BasicParser::PLUS

      || _la == BasicParser::MINUS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(640);
    _la = _input->LA(1);
    if (!(_la == BasicParser::NUMBER

    || _la == BasicParser::FLOAT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_Context ------------------------------------------------------------------

BasicParser::Func_Context::Func_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::Func_Context::STRINGLITERAL() {
  return getToken(BasicParser::STRINGLITERAL, 0);
}

BasicParser::NumberContext* BasicParser::Func_Context::number() {
  return getRuleContext<BasicParser::NumberContext>(0);
}

BasicParser::TabfuncContext* BasicParser::Func_Context::tabfunc() {
  return getRuleContext<BasicParser::TabfuncContext>(0);
}

BasicParser::VardeclContext* BasicParser::Func_Context::vardecl() {
  return getRuleContext<BasicParser::VardeclContext>(0);
}

BasicParser::ChrfuncContext* BasicParser::Func_Context::chrfunc() {
  return getRuleContext<BasicParser::ChrfuncContext>(0);
}

BasicParser::SqrfuncContext* BasicParser::Func_Context::sqrfunc() {
  return getRuleContext<BasicParser::SqrfuncContext>(0);
}

BasicParser::LenfuncContext* BasicParser::Func_Context::lenfunc() {
  return getRuleContext<BasicParser::LenfuncContext>(0);
}

BasicParser::StrfuncContext* BasicParser::Func_Context::strfunc() {
  return getRuleContext<BasicParser::StrfuncContext>(0);
}

BasicParser::AscfuncContext* BasicParser::Func_Context::ascfunc() {
  return getRuleContext<BasicParser::AscfuncContext>(0);
}

BasicParser::ScrnfuncContext* BasicParser::Func_Context::scrnfunc() {
  return getRuleContext<BasicParser::ScrnfuncContext>(0);
}

BasicParser::MidfuncContext* BasicParser::Func_Context::midfunc() {
  return getRuleContext<BasicParser::MidfuncContext>(0);
}

BasicParser::PdlfuncContext* BasicParser::Func_Context::pdlfunc() {
  return getRuleContext<BasicParser::PdlfuncContext>(0);
}

BasicParser::PeekfuncContext* BasicParser::Func_Context::peekfunc() {
  return getRuleContext<BasicParser::PeekfuncContext>(0);
}

BasicParser::IntfuncContext* BasicParser::Func_Context::intfunc() {
  return getRuleContext<BasicParser::IntfuncContext>(0);
}

BasicParser::SpcfuncContext* BasicParser::Func_Context::spcfunc() {
  return getRuleContext<BasicParser::SpcfuncContext>(0);
}

BasicParser::FrefuncContext* BasicParser::Func_Context::frefunc() {
  return getRuleContext<BasicParser::FrefuncContext>(0);
}

BasicParser::PosfuncContext* BasicParser::Func_Context::posfunc() {
  return getRuleContext<BasicParser::PosfuncContext>(0);
}

BasicParser::UsrfuncContext* BasicParser::Func_Context::usrfunc() {
  return getRuleContext<BasicParser::UsrfuncContext>(0);
}

BasicParser::LeftfuncContext* BasicParser::Func_Context::leftfunc() {
  return getRuleContext<BasicParser::LeftfuncContext>(0);
}

BasicParser::ValfuncContext* BasicParser::Func_Context::valfunc() {
  return getRuleContext<BasicParser::ValfuncContext>(0);
}

BasicParser::RightfuncContext* BasicParser::Func_Context::rightfunc() {
  return getRuleContext<BasicParser::RightfuncContext>(0);
}

BasicParser::FnfuncContext* BasicParser::Func_Context::fnfunc() {
  return getRuleContext<BasicParser::FnfuncContext>(0);
}

BasicParser::SinfuncContext* BasicParser::Func_Context::sinfunc() {
  return getRuleContext<BasicParser::SinfuncContext>(0);
}

BasicParser::CosfuncContext* BasicParser::Func_Context::cosfunc() {
  return getRuleContext<BasicParser::CosfuncContext>(0);
}

BasicParser::TanfuncContext* BasicParser::Func_Context::tanfunc() {
  return getRuleContext<BasicParser::TanfuncContext>(0);
}

BasicParser::AtnfuncContext* BasicParser::Func_Context::atnfunc() {
  return getRuleContext<BasicParser::AtnfuncContext>(0);
}

BasicParser::RndfuncContext* BasicParser::Func_Context::rndfunc() {
  return getRuleContext<BasicParser::RndfuncContext>(0);
}

BasicParser::SgnfuncContext* BasicParser::Func_Context::sgnfunc() {
  return getRuleContext<BasicParser::SgnfuncContext>(0);
}

BasicParser::ExpfuncContext* BasicParser::Func_Context::expfunc() {
  return getRuleContext<BasicParser::ExpfuncContext>(0);
}

BasicParser::LogfuncContext* BasicParser::Func_Context::logfunc() {
  return getRuleContext<BasicParser::LogfuncContext>(0);
}

BasicParser::AbsfuncContext* BasicParser::Func_Context::absfunc() {
  return getRuleContext<BasicParser::AbsfuncContext>(0);
}

tree::TerminalNode* BasicParser::Func_Context::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::Func_Context::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::Func_Context::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::Func_Context::getRuleIndex() const {
  return BasicParser::RuleFunc_;
}


std::any BasicParser::Func_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitFunc_(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::Func_Context* BasicParser::func_() {
  Func_Context *_localctx = _tracker.createInstance<Func_Context>(_ctx, getState());
  enterRule(_localctx, 122, BasicParser::RuleFunc_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(677);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case BasicParser::STRINGLITERAL: {
        enterOuterAlt(_localctx, 1);
        setState(642);
        match(BasicParser::STRINGLITERAL);
        break;
      }

      case BasicParser::PLUS:
      case BasicParser::MINUS:
      case BasicParser::NUMBER:
      case BasicParser::FLOAT: {
        enterOuterAlt(_localctx, 2);
        setState(643);
        number();
        break;
      }

      case BasicParser::TAB: {
        enterOuterAlt(_localctx, 3);
        setState(644);
        tabfunc();
        break;
      }

      case BasicParser::LETTERS: {
        enterOuterAlt(_localctx, 4);
        setState(645);
        vardecl();
        break;
      }

      case BasicParser::CHR: {
        enterOuterAlt(_localctx, 5);
        setState(646);
        chrfunc();
        break;
      }

      case BasicParser::SQR: {
        enterOuterAlt(_localctx, 6);
        setState(647);
        sqrfunc();
        break;
      }

      case BasicParser::LEN: {
        enterOuterAlt(_localctx, 7);
        setState(648);
        lenfunc();
        break;
      }

      case BasicParser::STR: {
        enterOuterAlt(_localctx, 8);
        setState(649);
        strfunc();
        break;
      }

      case BasicParser::ASC: {
        enterOuterAlt(_localctx, 9);
        setState(650);
        ascfunc();
        break;
      }

      case BasicParser::SCRN: {
        enterOuterAlt(_localctx, 10);
        setState(651);
        scrnfunc();
        break;
      }

      case BasicParser::MID: {
        enterOuterAlt(_localctx, 11);
        setState(652);
        midfunc();
        break;
      }

      case BasicParser::PDL: {
        enterOuterAlt(_localctx, 12);
        setState(653);
        pdlfunc();
        break;
      }

      case BasicParser::PEEK: {
        enterOuterAlt(_localctx, 13);
        setState(654);
        peekfunc();
        break;
      }

      case BasicParser::INTF: {
        enterOuterAlt(_localctx, 14);
        setState(655);
        intfunc();
        break;
      }

      case BasicParser::SPC: {
        enterOuterAlt(_localctx, 15);
        setState(656);
        spcfunc();
        break;
      }

      case BasicParser::FRE: {
        enterOuterAlt(_localctx, 16);
        setState(657);
        frefunc();
        break;
      }

      case BasicParser::POS: {
        enterOuterAlt(_localctx, 17);
        setState(658);
        posfunc();
        break;
      }

      case BasicParser::USR: {
        enterOuterAlt(_localctx, 18);
        setState(659);
        usrfunc();
        break;
      }

      case BasicParser::LEFT: {
        enterOuterAlt(_localctx, 19);
        setState(660);
        leftfunc();
        break;
      }

      case BasicParser::VAL: {
        enterOuterAlt(_localctx, 20);
        setState(661);
        valfunc();
        break;
      }

      case BasicParser::RIGHT: {
        enterOuterAlt(_localctx, 21);
        setState(662);
        rightfunc();
        break;
      }

      case BasicParser::FN: {
        enterOuterAlt(_localctx, 22);
        setState(663);
        fnfunc();
        break;
      }

      case BasicParser::SIN: {
        enterOuterAlt(_localctx, 23);
        setState(664);
        sinfunc();
        break;
      }

      case BasicParser::COS: {
        enterOuterAlt(_localctx, 24);
        setState(665);
        cosfunc();
        break;
      }

      case BasicParser::TAN: {
        enterOuterAlt(_localctx, 25);
        setState(666);
        tanfunc();
        break;
      }

      case BasicParser::ATN: {
        enterOuterAlt(_localctx, 26);
        setState(667);
        atnfunc();
        break;
      }

      case BasicParser::RND: {
        enterOuterAlt(_localctx, 27);
        setState(668);
        rndfunc();
        break;
      }

      case BasicParser::SGN: {
        enterOuterAlt(_localctx, 28);
        setState(669);
        sgnfunc();
        break;
      }

      case BasicParser::EXP: {
        enterOuterAlt(_localctx, 29);
        setState(670);
        expfunc();
        break;
      }

      case BasicParser::LOG: {
        enterOuterAlt(_localctx, 30);
        setState(671);
        logfunc();
        break;
      }

      case BasicParser::ABS: {
        enterOuterAlt(_localctx, 31);
        setState(672);
        absfunc();
        break;
      }

      case BasicParser::LPAREN: {
        enterOuterAlt(_localctx, 32);
        setState(673);
        match(BasicParser::LPAREN);
        setState(674);
        expression();
        setState(675);
        match(BasicParser::RPAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignExpressionContext ------------------------------------------------------------------

BasicParser::SignExpressionContext::SignExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

BasicParser::Func_Context* BasicParser::SignExpressionContext::func_() {
  return getRuleContext<BasicParser::Func_Context>(0);
}

tree::TerminalNode* BasicParser::SignExpressionContext::NOT() {
  return getToken(BasicParser::NOT, 0);
}

tree::TerminalNode* BasicParser::SignExpressionContext::PLUS() {
  return getToken(BasicParser::PLUS, 0);
}

tree::TerminalNode* BasicParser::SignExpressionContext::MINUS() {
  return getToken(BasicParser::MINUS, 0);
}


size_t BasicParser::SignExpressionContext::getRuleIndex() const {
  return BasicParser::RuleSignExpression;
}


std::any BasicParser::SignExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitSignExpression(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::SignExpressionContext* BasicParser::signExpression() {
  SignExpressionContext *_localctx = _tracker.createInstance<SignExpressionContext>(_ctx, getState());
  enterRule(_localctx, 124, BasicParser::RuleSignExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(680);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == BasicParser::NOT) {
      setState(679);
      match(BasicParser::NOT);
    }
    setState(683);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
    case 1: {
      setState(682);
      _la = _input->LA(1);
      if (!(_la == BasicParser::PLUS

      || _la == BasicParser::MINUS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(685);
    func_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExponentExpressionContext ------------------------------------------------------------------

BasicParser::ExponentExpressionContext::ExponentExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<BasicParser::SignExpressionContext *> BasicParser::ExponentExpressionContext::signExpression() {
  return getRuleContexts<BasicParser::SignExpressionContext>();
}

BasicParser::SignExpressionContext* BasicParser::ExponentExpressionContext::signExpression(size_t i) {
  return getRuleContext<BasicParser::SignExpressionContext>(i);
}

std::vector<tree::TerminalNode *> BasicParser::ExponentExpressionContext::EXPONENT() {
  return getTokens(BasicParser::EXPONENT);
}

tree::TerminalNode* BasicParser::ExponentExpressionContext::EXPONENT(size_t i) {
  return getToken(BasicParser::EXPONENT, i);
}


size_t BasicParser::ExponentExpressionContext::getRuleIndex() const {
  return BasicParser::RuleExponentExpression;
}


std::any BasicParser::ExponentExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitExponentExpression(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::ExponentExpressionContext* BasicParser::exponentExpression() {
  ExponentExpressionContext *_localctx = _tracker.createInstance<ExponentExpressionContext>(_ctx, getState());
  enterRule(_localctx, 126, BasicParser::RuleExponentExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(687);
    signExpression();
    setState(692);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == BasicParser::EXPONENT) {
      setState(688);
      match(BasicParser::EXPONENT);
      setState(689);
      signExpression();
      setState(694);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiplyingExpressionContext ------------------------------------------------------------------

BasicParser::MultiplyingExpressionContext::MultiplyingExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<BasicParser::ExponentExpressionContext *> BasicParser::MultiplyingExpressionContext::exponentExpression() {
  return getRuleContexts<BasicParser::ExponentExpressionContext>();
}

BasicParser::ExponentExpressionContext* BasicParser::MultiplyingExpressionContext::exponentExpression(size_t i) {
  return getRuleContext<BasicParser::ExponentExpressionContext>(i);
}

std::vector<tree::TerminalNode *> BasicParser::MultiplyingExpressionContext::TIMES() {
  return getTokens(BasicParser::TIMES);
}

tree::TerminalNode* BasicParser::MultiplyingExpressionContext::TIMES(size_t i) {
  return getToken(BasicParser::TIMES, i);
}

std::vector<tree::TerminalNode *> BasicParser::MultiplyingExpressionContext::DIV() {
  return getTokens(BasicParser::DIV);
}

tree::TerminalNode* BasicParser::MultiplyingExpressionContext::DIV(size_t i) {
  return getToken(BasicParser::DIV, i);
}


size_t BasicParser::MultiplyingExpressionContext::getRuleIndex() const {
  return BasicParser::RuleMultiplyingExpression;
}


std::any BasicParser::MultiplyingExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitMultiplyingExpression(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::MultiplyingExpressionContext* BasicParser::multiplyingExpression() {
  MultiplyingExpressionContext *_localctx = _tracker.createInstance<MultiplyingExpressionContext>(_ctx, getState());
  enterRule(_localctx, 128, BasicParser::RuleMultiplyingExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(695);
    exponentExpression();
    setState(700);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == BasicParser::TIMES

    || _la == BasicParser::DIV) {
      setState(696);
      _la = _input->LA(1);
      if (!(_la == BasicParser::TIMES

      || _la == BasicParser::DIV)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(697);
      exponentExpression();
      setState(702);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AddingExpressionContext ------------------------------------------------------------------

BasicParser::AddingExpressionContext::AddingExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<BasicParser::MultiplyingExpressionContext *> BasicParser::AddingExpressionContext::multiplyingExpression() {
  return getRuleContexts<BasicParser::MultiplyingExpressionContext>();
}

BasicParser::MultiplyingExpressionContext* BasicParser::AddingExpressionContext::multiplyingExpression(size_t i) {
  return getRuleContext<BasicParser::MultiplyingExpressionContext>(i);
}

std::vector<tree::TerminalNode *> BasicParser::AddingExpressionContext::PLUS() {
  return getTokens(BasicParser::PLUS);
}

tree::TerminalNode* BasicParser::AddingExpressionContext::PLUS(size_t i) {
  return getToken(BasicParser::PLUS, i);
}

std::vector<tree::TerminalNode *> BasicParser::AddingExpressionContext::MINUS() {
  return getTokens(BasicParser::MINUS);
}

tree::TerminalNode* BasicParser::AddingExpressionContext::MINUS(size_t i) {
  return getToken(BasicParser::MINUS, i);
}


size_t BasicParser::AddingExpressionContext::getRuleIndex() const {
  return BasicParser::RuleAddingExpression;
}


std::any BasicParser::AddingExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitAddingExpression(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::AddingExpressionContext* BasicParser::addingExpression() {
  AddingExpressionContext *_localctx = _tracker.createInstance<AddingExpressionContext>(_ctx, getState());
  enterRule(_localctx, 130, BasicParser::RuleAddingExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(703);
    multiplyingExpression();
    setState(708);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == BasicParser::PLUS

    || _la == BasicParser::MINUS) {
      setState(704);
      _la = _input->LA(1);
      if (!(_la == BasicParser::PLUS

      || _la == BasicParser::MINUS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(705);
      multiplyingExpression();
      setState(710);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationalExpressionContext ------------------------------------------------------------------

BasicParser::RelationalExpressionContext::RelationalExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<BasicParser::AddingExpressionContext *> BasicParser::RelationalExpressionContext::addingExpression() {
  return getRuleContexts<BasicParser::AddingExpressionContext>();
}

BasicParser::AddingExpressionContext* BasicParser::RelationalExpressionContext::addingExpression(size_t i) {
  return getRuleContext<BasicParser::AddingExpressionContext>(i);
}

BasicParser::RelopContext* BasicParser::RelationalExpressionContext::relop() {
  return getRuleContext<BasicParser::RelopContext>(0);
}


size_t BasicParser::RelationalExpressionContext::getRuleIndex() const {
  return BasicParser::RuleRelationalExpression;
}


std::any BasicParser::RelationalExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitRelationalExpression(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::RelationalExpressionContext* BasicParser::relationalExpression() {
  RelationalExpressionContext *_localctx = _tracker.createInstance<RelationalExpressionContext>(_ctx, getState());
  enterRule(_localctx, 132, BasicParser::RuleRelationalExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(711);
    addingExpression();
    setState(715);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4420796416) != 0)) {
      setState(712);
      relop();
      setState(713);
      addingExpression();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

BasicParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

BasicParser::Func_Context* BasicParser::ExpressionContext::func_() {
  return getRuleContext<BasicParser::Func_Context>(0);
}

std::vector<BasicParser::RelationalExpressionContext *> BasicParser::ExpressionContext::relationalExpression() {
  return getRuleContexts<BasicParser::RelationalExpressionContext>();
}

BasicParser::RelationalExpressionContext* BasicParser::ExpressionContext::relationalExpression(size_t i) {
  return getRuleContext<BasicParser::RelationalExpressionContext>(i);
}

std::vector<tree::TerminalNode *> BasicParser::ExpressionContext::AND() {
  return getTokens(BasicParser::AND);
}

tree::TerminalNode* BasicParser::ExpressionContext::AND(size_t i) {
  return getToken(BasicParser::AND, i);
}

std::vector<tree::TerminalNode *> BasicParser::ExpressionContext::OR() {
  return getTokens(BasicParser::OR);
}

tree::TerminalNode* BasicParser::ExpressionContext::OR(size_t i) {
  return getToken(BasicParser::OR, i);
}


size_t BasicParser::ExpressionContext::getRuleIndex() const {
  return BasicParser::RuleExpression;
}


std::any BasicParser::ExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::ExpressionContext* BasicParser::expression() {
  ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, getState());
  enterRule(_localctx, 134, BasicParser::RuleExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(726);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(717);
      func_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(718);
      relationalExpression();
      setState(723);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == BasicParser::AND

      || _la == BasicParser::OR) {
        setState(719);
        _la = _input->LA(1);
        if (!(_la == BasicParser::AND

        || _la == BasicParser::OR)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(720);
        relationalExpression();
        setState(725);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_Context ------------------------------------------------------------------

BasicParser::Var_Context::Var_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

BasicParser::VarnameContext* BasicParser::Var_Context::varname() {
  return getRuleContext<BasicParser::VarnameContext>(0);
}

BasicParser::VarsuffixContext* BasicParser::Var_Context::varsuffix() {
  return getRuleContext<BasicParser::VarsuffixContext>(0);
}


size_t BasicParser::Var_Context::getRuleIndex() const {
  return BasicParser::RuleVar_;
}


std::any BasicParser::Var_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitVar_(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::Var_Context* BasicParser::var_() {
  Var_Context *_localctx = _tracker.createInstance<Var_Context>(_ctx, getState());
  enterRule(_localctx, 136, BasicParser::RuleVar_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(728);
    varname();
    setState(730);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == BasicParser::DOLLAR

    || _la == BasicParser::PERCENT) {
      setState(729);
      varsuffix();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarnameContext ------------------------------------------------------------------

BasicParser::VarnameContext::VarnameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> BasicParser::VarnameContext::LETTERS() {
  return getTokens(BasicParser::LETTERS);
}

tree::TerminalNode* BasicParser::VarnameContext::LETTERS(size_t i) {
  return getToken(BasicParser::LETTERS, i);
}

std::vector<tree::TerminalNode *> BasicParser::VarnameContext::NUMBER() {
  return getTokens(BasicParser::NUMBER);
}

tree::TerminalNode* BasicParser::VarnameContext::NUMBER(size_t i) {
  return getToken(BasicParser::NUMBER, i);
}


size_t BasicParser::VarnameContext::getRuleIndex() const {
  return BasicParser::RuleVarname;
}


std::any BasicParser::VarnameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitVarname(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::VarnameContext* BasicParser::varname() {
  VarnameContext *_localctx = _tracker.createInstance<VarnameContext>(_ctx, getState());
  enterRule(_localctx, 138, BasicParser::RuleVarname);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(732);
    match(BasicParser::LETTERS);
    setState(736);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(733);
        _la = _input->LA(1);
        if (!(_la == BasicParser::LETTERS

        || _la == BasicParser::NUMBER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        } 
      }
      setState(738);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarsuffixContext ------------------------------------------------------------------

BasicParser::VarsuffixContext::VarsuffixContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::VarsuffixContext::DOLLAR() {
  return getToken(BasicParser::DOLLAR, 0);
}

tree::TerminalNode* BasicParser::VarsuffixContext::PERCENT() {
  return getToken(BasicParser::PERCENT, 0);
}


size_t BasicParser::VarsuffixContext::getRuleIndex() const {
  return BasicParser::RuleVarsuffix;
}


std::any BasicParser::VarsuffixContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitVarsuffix(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::VarsuffixContext* BasicParser::varsuffix() {
  VarsuffixContext *_localctx = _tracker.createInstance<VarsuffixContext>(_ctx, getState());
  enterRule(_localctx, 140, BasicParser::RuleVarsuffix);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(739);
    _la = _input->LA(1);
    if (!(_la == BasicParser::DOLLAR

    || _la == BasicParser::PERCENT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarlistContext ------------------------------------------------------------------

BasicParser::VarlistContext::VarlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<BasicParser::VardeclContext *> BasicParser::VarlistContext::vardecl() {
  return getRuleContexts<BasicParser::VardeclContext>();
}

BasicParser::VardeclContext* BasicParser::VarlistContext::vardecl(size_t i) {
  return getRuleContext<BasicParser::VardeclContext>(i);
}

std::vector<tree::TerminalNode *> BasicParser::VarlistContext::COMMA() {
  return getTokens(BasicParser::COMMA);
}

tree::TerminalNode* BasicParser::VarlistContext::COMMA(size_t i) {
  return getToken(BasicParser::COMMA, i);
}


size_t BasicParser::VarlistContext::getRuleIndex() const {
  return BasicParser::RuleVarlist;
}


std::any BasicParser::VarlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitVarlist(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::VarlistContext* BasicParser::varlist() {
  VarlistContext *_localctx = _tracker.createInstance<VarlistContext>(_ctx, getState());
  enterRule(_localctx, 142, BasicParser::RuleVarlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(741);
    vardecl();
    setState(746);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == BasicParser::COMMA) {
      setState(742);
      match(BasicParser::COMMA);
      setState(743);
      vardecl();
      setState(748);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprlistContext ------------------------------------------------------------------

BasicParser::ExprlistContext::ExprlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<BasicParser::ExpressionContext *> BasicParser::ExprlistContext::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::ExprlistContext::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> BasicParser::ExprlistContext::COMMA() {
  return getTokens(BasicParser::COMMA);
}

tree::TerminalNode* BasicParser::ExprlistContext::COMMA(size_t i) {
  return getToken(BasicParser::COMMA, i);
}


size_t BasicParser::ExprlistContext::getRuleIndex() const {
  return BasicParser::RuleExprlist;
}


std::any BasicParser::ExprlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitExprlist(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::ExprlistContext* BasicParser::exprlist() {
  ExprlistContext *_localctx = _tracker.createInstance<ExprlistContext>(_ctx, getState());
  enterRule(_localctx, 144, BasicParser::RuleExprlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(749);
    expression();
    setState(754);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == BasicParser::COMMA) {
      setState(750);
      match(BasicParser::COMMA);
      setState(751);
      expression();
      setState(756);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SqrfuncContext ------------------------------------------------------------------

BasicParser::SqrfuncContext::SqrfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::SqrfuncContext::SQR() {
  return getToken(BasicParser::SQR, 0);
}

tree::TerminalNode* BasicParser::SqrfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::SqrfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::SqrfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::SqrfuncContext::getRuleIndex() const {
  return BasicParser::RuleSqrfunc;
}


std::any BasicParser::SqrfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitSqrfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::SqrfuncContext* BasicParser::sqrfunc() {
  SqrfuncContext *_localctx = _tracker.createInstance<SqrfuncContext>(_ctx, getState());
  enterRule(_localctx, 146, BasicParser::RuleSqrfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(757);
    match(BasicParser::SQR);
    setState(758);
    match(BasicParser::LPAREN);
    setState(759);
    expression();
    setState(760);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChrfuncContext ------------------------------------------------------------------

BasicParser::ChrfuncContext::ChrfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::ChrfuncContext::CHR() {
  return getToken(BasicParser::CHR, 0);
}

tree::TerminalNode* BasicParser::ChrfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::ChrfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::ChrfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::ChrfuncContext::getRuleIndex() const {
  return BasicParser::RuleChrfunc;
}


std::any BasicParser::ChrfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitChrfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::ChrfuncContext* BasicParser::chrfunc() {
  ChrfuncContext *_localctx = _tracker.createInstance<ChrfuncContext>(_ctx, getState());
  enterRule(_localctx, 148, BasicParser::RuleChrfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(762);
    match(BasicParser::CHR);
    setState(763);
    match(BasicParser::LPAREN);
    setState(764);
    expression();
    setState(765);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LenfuncContext ------------------------------------------------------------------

BasicParser::LenfuncContext::LenfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::LenfuncContext::LEN() {
  return getToken(BasicParser::LEN, 0);
}

tree::TerminalNode* BasicParser::LenfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::LenfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::LenfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::LenfuncContext::getRuleIndex() const {
  return BasicParser::RuleLenfunc;
}


std::any BasicParser::LenfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitLenfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::LenfuncContext* BasicParser::lenfunc() {
  LenfuncContext *_localctx = _tracker.createInstance<LenfuncContext>(_ctx, getState());
  enterRule(_localctx, 150, BasicParser::RuleLenfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(767);
    match(BasicParser::LEN);
    setState(768);
    match(BasicParser::LPAREN);
    setState(769);
    expression();
    setState(770);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AscfuncContext ------------------------------------------------------------------

BasicParser::AscfuncContext::AscfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::AscfuncContext::ASC() {
  return getToken(BasicParser::ASC, 0);
}

tree::TerminalNode* BasicParser::AscfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::AscfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::AscfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::AscfuncContext::getRuleIndex() const {
  return BasicParser::RuleAscfunc;
}


std::any BasicParser::AscfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitAscfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::AscfuncContext* BasicParser::ascfunc() {
  AscfuncContext *_localctx = _tracker.createInstance<AscfuncContext>(_ctx, getState());
  enterRule(_localctx, 152, BasicParser::RuleAscfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(772);
    match(BasicParser::ASC);
    setState(773);
    match(BasicParser::LPAREN);
    setState(774);
    expression();
    setState(775);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MidfuncContext ------------------------------------------------------------------

BasicParser::MidfuncContext::MidfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::MidfuncContext::MID() {
  return getToken(BasicParser::MID, 0);
}

tree::TerminalNode* BasicParser::MidfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

std::vector<BasicParser::ExpressionContext *> BasicParser::MidfuncContext::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::MidfuncContext::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> BasicParser::MidfuncContext::COMMA() {
  return getTokens(BasicParser::COMMA);
}

tree::TerminalNode* BasicParser::MidfuncContext::COMMA(size_t i) {
  return getToken(BasicParser::COMMA, i);
}

tree::TerminalNode* BasicParser::MidfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::MidfuncContext::getRuleIndex() const {
  return BasicParser::RuleMidfunc;
}


std::any BasicParser::MidfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitMidfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::MidfuncContext* BasicParser::midfunc() {
  MidfuncContext *_localctx = _tracker.createInstance<MidfuncContext>(_ctx, getState());
  enterRule(_localctx, 154, BasicParser::RuleMidfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(777);
    match(BasicParser::MID);
    setState(778);
    match(BasicParser::LPAREN);
    setState(779);
    expression();
    setState(780);
    match(BasicParser::COMMA);
    setState(781);
    expression();
    setState(782);
    match(BasicParser::COMMA);
    setState(783);
    expression();
    setState(784);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PdlfuncContext ------------------------------------------------------------------

BasicParser::PdlfuncContext::PdlfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::PdlfuncContext::PDL() {
  return getToken(BasicParser::PDL, 0);
}

tree::TerminalNode* BasicParser::PdlfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::PdlfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::PdlfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::PdlfuncContext::getRuleIndex() const {
  return BasicParser::RulePdlfunc;
}


std::any BasicParser::PdlfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitPdlfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::PdlfuncContext* BasicParser::pdlfunc() {
  PdlfuncContext *_localctx = _tracker.createInstance<PdlfuncContext>(_ctx, getState());
  enterRule(_localctx, 156, BasicParser::RulePdlfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(786);
    match(BasicParser::PDL);
    setState(787);
    match(BasicParser::LPAREN);
    setState(788);
    expression();
    setState(789);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PeekfuncContext ------------------------------------------------------------------

BasicParser::PeekfuncContext::PeekfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::PeekfuncContext::PEEK() {
  return getToken(BasicParser::PEEK, 0);
}

tree::TerminalNode* BasicParser::PeekfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::PeekfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::PeekfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::PeekfuncContext::getRuleIndex() const {
  return BasicParser::RulePeekfunc;
}


std::any BasicParser::PeekfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitPeekfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::PeekfuncContext* BasicParser::peekfunc() {
  PeekfuncContext *_localctx = _tracker.createInstance<PeekfuncContext>(_ctx, getState());
  enterRule(_localctx, 158, BasicParser::RulePeekfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(791);
    match(BasicParser::PEEK);
    setState(792);
    match(BasicParser::LPAREN);
    setState(793);
    expression();
    setState(794);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntfuncContext ------------------------------------------------------------------

BasicParser::IntfuncContext::IntfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::IntfuncContext::INTF() {
  return getToken(BasicParser::INTF, 0);
}

tree::TerminalNode* BasicParser::IntfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::IntfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::IntfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::IntfuncContext::getRuleIndex() const {
  return BasicParser::RuleIntfunc;
}


std::any BasicParser::IntfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitIntfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::IntfuncContext* BasicParser::intfunc() {
  IntfuncContext *_localctx = _tracker.createInstance<IntfuncContext>(_ctx, getState());
  enterRule(_localctx, 160, BasicParser::RuleIntfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(796);
    match(BasicParser::INTF);
    setState(797);
    match(BasicParser::LPAREN);
    setState(798);
    expression();
    setState(799);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpcfuncContext ------------------------------------------------------------------

BasicParser::SpcfuncContext::SpcfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::SpcfuncContext::SPC() {
  return getToken(BasicParser::SPC, 0);
}

tree::TerminalNode* BasicParser::SpcfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::SpcfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::SpcfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::SpcfuncContext::getRuleIndex() const {
  return BasicParser::RuleSpcfunc;
}


std::any BasicParser::SpcfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitSpcfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::SpcfuncContext* BasicParser::spcfunc() {
  SpcfuncContext *_localctx = _tracker.createInstance<SpcfuncContext>(_ctx, getState());
  enterRule(_localctx, 162, BasicParser::RuleSpcfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(801);
    match(BasicParser::SPC);
    setState(802);
    match(BasicParser::LPAREN);
    setState(803);
    expression();
    setState(804);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FrefuncContext ------------------------------------------------------------------

BasicParser::FrefuncContext::FrefuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::FrefuncContext::FRE() {
  return getToken(BasicParser::FRE, 0);
}

tree::TerminalNode* BasicParser::FrefuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::FrefuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::FrefuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::FrefuncContext::getRuleIndex() const {
  return BasicParser::RuleFrefunc;
}


std::any BasicParser::FrefuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitFrefunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::FrefuncContext* BasicParser::frefunc() {
  FrefuncContext *_localctx = _tracker.createInstance<FrefuncContext>(_ctx, getState());
  enterRule(_localctx, 164, BasicParser::RuleFrefunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(806);
    match(BasicParser::FRE);
    setState(807);
    match(BasicParser::LPAREN);
    setState(808);
    expression();
    setState(809);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PosfuncContext ------------------------------------------------------------------

BasicParser::PosfuncContext::PosfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::PosfuncContext::POS() {
  return getToken(BasicParser::POS, 0);
}

tree::TerminalNode* BasicParser::PosfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::PosfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::PosfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::PosfuncContext::getRuleIndex() const {
  return BasicParser::RulePosfunc;
}


std::any BasicParser::PosfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitPosfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::PosfuncContext* BasicParser::posfunc() {
  PosfuncContext *_localctx = _tracker.createInstance<PosfuncContext>(_ctx, getState());
  enterRule(_localctx, 166, BasicParser::RulePosfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(811);
    match(BasicParser::POS);
    setState(812);
    match(BasicParser::LPAREN);
    setState(813);
    expression();
    setState(814);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UsrfuncContext ------------------------------------------------------------------

BasicParser::UsrfuncContext::UsrfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::UsrfuncContext::USR() {
  return getToken(BasicParser::USR, 0);
}

tree::TerminalNode* BasicParser::UsrfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::UsrfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::UsrfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::UsrfuncContext::getRuleIndex() const {
  return BasicParser::RuleUsrfunc;
}


std::any BasicParser::UsrfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitUsrfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::UsrfuncContext* BasicParser::usrfunc() {
  UsrfuncContext *_localctx = _tracker.createInstance<UsrfuncContext>(_ctx, getState());
  enterRule(_localctx, 168, BasicParser::RuleUsrfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(816);
    match(BasicParser::USR);
    setState(817);
    match(BasicParser::LPAREN);
    setState(818);
    expression();
    setState(819);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LeftfuncContext ------------------------------------------------------------------

BasicParser::LeftfuncContext::LeftfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::LeftfuncContext::LEFT() {
  return getToken(BasicParser::LEFT, 0);
}

tree::TerminalNode* BasicParser::LeftfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

std::vector<BasicParser::ExpressionContext *> BasicParser::LeftfuncContext::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::LeftfuncContext::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

tree::TerminalNode* BasicParser::LeftfuncContext::COMMA() {
  return getToken(BasicParser::COMMA, 0);
}

tree::TerminalNode* BasicParser::LeftfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::LeftfuncContext::getRuleIndex() const {
  return BasicParser::RuleLeftfunc;
}


std::any BasicParser::LeftfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitLeftfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::LeftfuncContext* BasicParser::leftfunc() {
  LeftfuncContext *_localctx = _tracker.createInstance<LeftfuncContext>(_ctx, getState());
  enterRule(_localctx, 170, BasicParser::RuleLeftfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(821);
    match(BasicParser::LEFT);
    setState(822);
    match(BasicParser::LPAREN);
    setState(823);
    expression();
    setState(824);
    match(BasicParser::COMMA);
    setState(825);
    expression();
    setState(826);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RightfuncContext ------------------------------------------------------------------

BasicParser::RightfuncContext::RightfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::RightfuncContext::RIGHT() {
  return getToken(BasicParser::RIGHT, 0);
}

tree::TerminalNode* BasicParser::RightfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

std::vector<BasicParser::ExpressionContext *> BasicParser::RightfuncContext::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::RightfuncContext::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

tree::TerminalNode* BasicParser::RightfuncContext::COMMA() {
  return getToken(BasicParser::COMMA, 0);
}

tree::TerminalNode* BasicParser::RightfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::RightfuncContext::getRuleIndex() const {
  return BasicParser::RuleRightfunc;
}


std::any BasicParser::RightfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitRightfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::RightfuncContext* BasicParser::rightfunc() {
  RightfuncContext *_localctx = _tracker.createInstance<RightfuncContext>(_ctx, getState());
  enterRule(_localctx, 172, BasicParser::RuleRightfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(828);
    match(BasicParser::RIGHT);
    setState(829);
    match(BasicParser::LPAREN);
    setState(830);
    expression();
    setState(831);
    match(BasicParser::COMMA);
    setState(832);
    expression();
    setState(833);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StrfuncContext ------------------------------------------------------------------

BasicParser::StrfuncContext::StrfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::StrfuncContext::STR() {
  return getToken(BasicParser::STR, 0);
}

tree::TerminalNode* BasicParser::StrfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::StrfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::StrfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::StrfuncContext::getRuleIndex() const {
  return BasicParser::RuleStrfunc;
}


std::any BasicParser::StrfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitStrfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::StrfuncContext* BasicParser::strfunc() {
  StrfuncContext *_localctx = _tracker.createInstance<StrfuncContext>(_ctx, getState());
  enterRule(_localctx, 174, BasicParser::RuleStrfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(835);
    match(BasicParser::STR);
    setState(836);
    match(BasicParser::LPAREN);
    setState(837);
    expression();
    setState(838);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FnfuncContext ------------------------------------------------------------------

BasicParser::FnfuncContext::FnfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::FnfuncContext::FN() {
  return getToken(BasicParser::FN, 0);
}

BasicParser::Var_Context* BasicParser::FnfuncContext::var_() {
  return getRuleContext<BasicParser::Var_Context>(0);
}

tree::TerminalNode* BasicParser::FnfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::FnfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::FnfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::FnfuncContext::getRuleIndex() const {
  return BasicParser::RuleFnfunc;
}


std::any BasicParser::FnfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitFnfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::FnfuncContext* BasicParser::fnfunc() {
  FnfuncContext *_localctx = _tracker.createInstance<FnfuncContext>(_ctx, getState());
  enterRule(_localctx, 176, BasicParser::RuleFnfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(840);
    match(BasicParser::FN);
    setState(841);
    var_();
    setState(842);
    match(BasicParser::LPAREN);
    setState(843);
    expression();
    setState(844);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValfuncContext ------------------------------------------------------------------

BasicParser::ValfuncContext::ValfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::ValfuncContext::VAL() {
  return getToken(BasicParser::VAL, 0);
}

tree::TerminalNode* BasicParser::ValfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::ValfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::ValfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::ValfuncContext::getRuleIndex() const {
  return BasicParser::RuleValfunc;
}


std::any BasicParser::ValfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitValfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::ValfuncContext* BasicParser::valfunc() {
  ValfuncContext *_localctx = _tracker.createInstance<ValfuncContext>(_ctx, getState());
  enterRule(_localctx, 178, BasicParser::RuleValfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(846);
    match(BasicParser::VAL);
    setState(847);
    match(BasicParser::LPAREN);
    setState(848);
    expression();
    setState(849);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScrnfuncContext ------------------------------------------------------------------

BasicParser::ScrnfuncContext::ScrnfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::ScrnfuncContext::SCRN() {
  return getToken(BasicParser::SCRN, 0);
}

tree::TerminalNode* BasicParser::ScrnfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

std::vector<BasicParser::ExpressionContext *> BasicParser::ScrnfuncContext::expression() {
  return getRuleContexts<BasicParser::ExpressionContext>();
}

BasicParser::ExpressionContext* BasicParser::ScrnfuncContext::expression(size_t i) {
  return getRuleContext<BasicParser::ExpressionContext>(i);
}

tree::TerminalNode* BasicParser::ScrnfuncContext::COMMA() {
  return getToken(BasicParser::COMMA, 0);
}

tree::TerminalNode* BasicParser::ScrnfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::ScrnfuncContext::getRuleIndex() const {
  return BasicParser::RuleScrnfunc;
}


std::any BasicParser::ScrnfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitScrnfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::ScrnfuncContext* BasicParser::scrnfunc() {
  ScrnfuncContext *_localctx = _tracker.createInstance<ScrnfuncContext>(_ctx, getState());
  enterRule(_localctx, 180, BasicParser::RuleScrnfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(851);
    match(BasicParser::SCRN);
    setState(852);
    match(BasicParser::LPAREN);
    setState(853);
    expression();
    setState(854);
    match(BasicParser::COMMA);
    setState(855);
    expression();
    setState(856);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SinfuncContext ------------------------------------------------------------------

BasicParser::SinfuncContext::SinfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::SinfuncContext::SIN() {
  return getToken(BasicParser::SIN, 0);
}

tree::TerminalNode* BasicParser::SinfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::SinfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::SinfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::SinfuncContext::getRuleIndex() const {
  return BasicParser::RuleSinfunc;
}


std::any BasicParser::SinfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitSinfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::SinfuncContext* BasicParser::sinfunc() {
  SinfuncContext *_localctx = _tracker.createInstance<SinfuncContext>(_ctx, getState());
  enterRule(_localctx, 182, BasicParser::RuleSinfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(858);
    match(BasicParser::SIN);
    setState(859);
    match(BasicParser::LPAREN);
    setState(860);
    expression();
    setState(861);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CosfuncContext ------------------------------------------------------------------

BasicParser::CosfuncContext::CosfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::CosfuncContext::COS() {
  return getToken(BasicParser::COS, 0);
}

tree::TerminalNode* BasicParser::CosfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::CosfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::CosfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::CosfuncContext::getRuleIndex() const {
  return BasicParser::RuleCosfunc;
}


std::any BasicParser::CosfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitCosfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::CosfuncContext* BasicParser::cosfunc() {
  CosfuncContext *_localctx = _tracker.createInstance<CosfuncContext>(_ctx, getState());
  enterRule(_localctx, 184, BasicParser::RuleCosfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(863);
    match(BasicParser::COS);
    setState(864);
    match(BasicParser::LPAREN);
    setState(865);
    expression();
    setState(866);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TanfuncContext ------------------------------------------------------------------

BasicParser::TanfuncContext::TanfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::TanfuncContext::TAN() {
  return getToken(BasicParser::TAN, 0);
}

tree::TerminalNode* BasicParser::TanfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::TanfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::TanfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::TanfuncContext::getRuleIndex() const {
  return BasicParser::RuleTanfunc;
}


std::any BasicParser::TanfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitTanfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::TanfuncContext* BasicParser::tanfunc() {
  TanfuncContext *_localctx = _tracker.createInstance<TanfuncContext>(_ctx, getState());
  enterRule(_localctx, 186, BasicParser::RuleTanfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(868);
    match(BasicParser::TAN);
    setState(869);
    match(BasicParser::LPAREN);
    setState(870);
    expression();
    setState(871);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AtnfuncContext ------------------------------------------------------------------

BasicParser::AtnfuncContext::AtnfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::AtnfuncContext::ATN() {
  return getToken(BasicParser::ATN, 0);
}

tree::TerminalNode* BasicParser::AtnfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::AtnfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::AtnfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::AtnfuncContext::getRuleIndex() const {
  return BasicParser::RuleAtnfunc;
}


std::any BasicParser::AtnfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitAtnfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::AtnfuncContext* BasicParser::atnfunc() {
  AtnfuncContext *_localctx = _tracker.createInstance<AtnfuncContext>(_ctx, getState());
  enterRule(_localctx, 188, BasicParser::RuleAtnfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(873);
    match(BasicParser::ATN);
    setState(874);
    match(BasicParser::LPAREN);
    setState(875);
    expression();
    setState(876);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RndfuncContext ------------------------------------------------------------------

BasicParser::RndfuncContext::RndfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::RndfuncContext::RND() {
  return getToken(BasicParser::RND, 0);
}

tree::TerminalNode* BasicParser::RndfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::RndfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::RndfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::RndfuncContext::getRuleIndex() const {
  return BasicParser::RuleRndfunc;
}


std::any BasicParser::RndfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitRndfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::RndfuncContext* BasicParser::rndfunc() {
  RndfuncContext *_localctx = _tracker.createInstance<RndfuncContext>(_ctx, getState());
  enterRule(_localctx, 190, BasicParser::RuleRndfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(878);
    match(BasicParser::RND);
    setState(879);
    match(BasicParser::LPAREN);
    setState(880);
    expression();
    setState(881);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SgnfuncContext ------------------------------------------------------------------

BasicParser::SgnfuncContext::SgnfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::SgnfuncContext::SGN() {
  return getToken(BasicParser::SGN, 0);
}

tree::TerminalNode* BasicParser::SgnfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::SgnfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::SgnfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::SgnfuncContext::getRuleIndex() const {
  return BasicParser::RuleSgnfunc;
}


std::any BasicParser::SgnfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitSgnfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::SgnfuncContext* BasicParser::sgnfunc() {
  SgnfuncContext *_localctx = _tracker.createInstance<SgnfuncContext>(_ctx, getState());
  enterRule(_localctx, 192, BasicParser::RuleSgnfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(883);
    match(BasicParser::SGN);
    setState(884);
    match(BasicParser::LPAREN);
    setState(885);
    expression();
    setState(886);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpfuncContext ------------------------------------------------------------------

BasicParser::ExpfuncContext::ExpfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::ExpfuncContext::EXP() {
  return getToken(BasicParser::EXP, 0);
}

tree::TerminalNode* BasicParser::ExpfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::ExpfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::ExpfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::ExpfuncContext::getRuleIndex() const {
  return BasicParser::RuleExpfunc;
}


std::any BasicParser::ExpfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitExpfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::ExpfuncContext* BasicParser::expfunc() {
  ExpfuncContext *_localctx = _tracker.createInstance<ExpfuncContext>(_ctx, getState());
  enterRule(_localctx, 194, BasicParser::RuleExpfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(888);
    match(BasicParser::EXP);
    setState(889);
    match(BasicParser::LPAREN);
    setState(890);
    expression();
    setState(891);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogfuncContext ------------------------------------------------------------------

BasicParser::LogfuncContext::LogfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::LogfuncContext::LOG() {
  return getToken(BasicParser::LOG, 0);
}

tree::TerminalNode* BasicParser::LogfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::LogfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::LogfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::LogfuncContext::getRuleIndex() const {
  return BasicParser::RuleLogfunc;
}


std::any BasicParser::LogfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitLogfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::LogfuncContext* BasicParser::logfunc() {
  LogfuncContext *_localctx = _tracker.createInstance<LogfuncContext>(_ctx, getState());
  enterRule(_localctx, 196, BasicParser::RuleLogfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(893);
    match(BasicParser::LOG);
    setState(894);
    match(BasicParser::LPAREN);
    setState(895);
    expression();
    setState(896);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AbsfuncContext ------------------------------------------------------------------

BasicParser::AbsfuncContext::AbsfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::AbsfuncContext::ABS() {
  return getToken(BasicParser::ABS, 0);
}

tree::TerminalNode* BasicParser::AbsfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::AbsfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::AbsfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::AbsfuncContext::getRuleIndex() const {
  return BasicParser::RuleAbsfunc;
}


std::any BasicParser::AbsfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitAbsfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::AbsfuncContext* BasicParser::absfunc() {
  AbsfuncContext *_localctx = _tracker.createInstance<AbsfuncContext>(_ctx, getState());
  enterRule(_localctx, 198, BasicParser::RuleAbsfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(898);
    match(BasicParser::ABS);
    setState(899);
    match(BasicParser::LPAREN);
    setState(900);
    expression();
    setState(901);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TabfuncContext ------------------------------------------------------------------

BasicParser::TabfuncContext::TabfuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* BasicParser::TabfuncContext::TAB() {
  return getToken(BasicParser::TAB, 0);
}

tree::TerminalNode* BasicParser::TabfuncContext::LPAREN() {
  return getToken(BasicParser::LPAREN, 0);
}

BasicParser::ExpressionContext* BasicParser::TabfuncContext::expression() {
  return getRuleContext<BasicParser::ExpressionContext>(0);
}

tree::TerminalNode* BasicParser::TabfuncContext::RPAREN() {
  return getToken(BasicParser::RPAREN, 0);
}


size_t BasicParser::TabfuncContext::getRuleIndex() const {
  return BasicParser::RuleTabfunc;
}


std::any BasicParser::TabfuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<BasicVisitor*>(visitor))
    return parserVisitor->visitTabfunc(this);
  else
    return visitor->visitChildren(this);
}

BasicParser::TabfuncContext* BasicParser::tabfunc() {
  TabfuncContext *_localctx = _tracker.createInstance<TabfuncContext>(_ctx, getState());
  enterRule(_localctx, 200, BasicParser::RuleTabfunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(903);
    match(BasicParser::TAB);
    setState(904);
    match(BasicParser::LPAREN);
    setState(905);
    expression();
    setState(906);
    match(BasicParser::RPAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

void BasicParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  basicParserInitialize();
#else
  ::antlr4::internal::call_once(basicParserOnceFlag, basicParserInitialize);
#endif
}
